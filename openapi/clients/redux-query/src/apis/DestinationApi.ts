// tslint:disable
/**
 * Airbyte Configuration API
 * Airbyte Configuration API [https://airbyte.io](https://airbyte.io).  This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.  Here are some conventions that this API follows: * All endpoints are http POST methods. * All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params. * The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`. * For all `update` methods, the whole object must be passed in, even the fields that did not change.  Change Management: * The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create` * Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests. * All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):   * Adding fields to request or response bodies.   * Adding new HTTP endpoints. * All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@airbyte.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CheckConnectionRead,
    CheckConnectionReadFromJSON,
    CheckConnectionReadToJSON,
    DestinationCreate,
    DestinationCreateFromJSON,
    DestinationCreateToJSON,
    DestinationIdRequestBody,
    DestinationIdRequestBodyFromJSON,
    DestinationIdRequestBodyToJSON,
    DestinationRead,
    DestinationReadFromJSON,
    DestinationReadToJSON,
    DestinationReadList,
    DestinationReadListFromJSON,
    DestinationReadListToJSON,
    DestinationSearch,
    DestinationSearchFromJSON,
    DestinationSearchToJSON,
    DestinationUpdate,
    DestinationUpdateFromJSON,
    DestinationUpdateToJSON,
    InvalidInputExceptionInfo,
    InvalidInputExceptionInfoFromJSON,
    InvalidInputExceptionInfoToJSON,
    NotFoundKnownExceptionInfo,
    NotFoundKnownExceptionInfoFromJSON,
    NotFoundKnownExceptionInfoToJSON,
    WorkspaceIdRequestBody,
    WorkspaceIdRequestBodyFromJSON,
    WorkspaceIdRequestBodyToJSON,
} from '../models';

export interface CheckConnectionToDestinationRequest {
    destinationIdRequestBody: DestinationIdRequestBody;
}

export interface CheckConnectionToDestinationForUpdateRequest {
    destinationUpdate: DestinationUpdate;
}

export interface CloneDestinationRequest {
    destinationIdRequestBody: DestinationIdRequestBody;
}

export interface CreateDestinationRequest {
    destinationCreate: DestinationCreate;
}

export interface DeleteDestinationRequest {
    destinationIdRequestBody: DestinationIdRequestBody;
}

export interface GetDestinationRequest {
    destinationIdRequestBody: DestinationIdRequestBody;
}

export interface ListDestinationsForWorkspaceRequest {
    workspaceIdRequestBody: WorkspaceIdRequestBody;
}

export interface SearchDestinationsRequest {
    destinationSearch: DestinationSearch;
}

export interface UpdateDestinationRequest {
    destinationUpdate: DestinationUpdate;
}


/**
 * Check connection to the destination
 */
function checkConnectionToDestinationRaw<T>(requestParameters: CheckConnectionToDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, CheckConnectionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationIdRequestBody === null || requestParameters.destinationIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationIdRequestBody','Required parameter requestParameters.destinationIdRequestBody was null or undefined when calling checkConnectionToDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/check_connection`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationIdRequestBodyToJSON(requestParameters.destinationIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CheckConnectionReadFromJSON(body), text);
    }

    return config;
}

/**
* Check connection to the destination
*/
export function checkConnectionToDestination<T>(requestParameters: CheckConnectionToDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, CheckConnectionRead>): QueryConfig<T> {
    return checkConnectionToDestinationRaw(requestParameters, requestConfig);
}

/**
 * Check connection for a proposed update to a destination
 */
function checkConnectionToDestinationForUpdateRaw<T>(requestParameters: CheckConnectionToDestinationForUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, CheckConnectionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationUpdate === null || requestParameters.destinationUpdate === undefined) {
        throw new runtime.RequiredError('destinationUpdate','Required parameter requestParameters.destinationUpdate was null or undefined when calling checkConnectionToDestinationForUpdate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/check_connection_for_update`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationUpdateToJSON(requestParameters.destinationUpdate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CheckConnectionReadFromJSON(body), text);
    }

    return config;
}

/**
* Check connection for a proposed update to a destination
*/
export function checkConnectionToDestinationForUpdate<T>(requestParameters: CheckConnectionToDestinationForUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, CheckConnectionRead>): QueryConfig<T> {
    return checkConnectionToDestinationForUpdateRaw(requestParameters, requestConfig);
}

/**
 * Clone destination
 */
function cloneDestinationRaw<T>(requestParameters: CloneDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationIdRequestBody === null || requestParameters.destinationIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationIdRequestBody','Required parameter requestParameters.destinationIdRequestBody was null or undefined when calling cloneDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/clone`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationIdRequestBodyToJSON(requestParameters.destinationIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadFromJSON(body), text);
    }

    return config;
}

/**
* Clone destination
*/
export function cloneDestination<T>(requestParameters: CloneDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationRead>): QueryConfig<T> {
    return cloneDestinationRaw(requestParameters, requestConfig);
}

/**
 * Create a destination
 */
function createDestinationRaw<T>(requestParameters: CreateDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationCreate === null || requestParameters.destinationCreate === undefined) {
        throw new runtime.RequiredError('destinationCreate','Required parameter requestParameters.destinationCreate was null or undefined when calling createDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/create`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationCreateToJSON(requestParameters.destinationCreate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadFromJSON(body), text);
    }

    return config;
}

/**
* Create a destination
*/
export function createDestination<T>(requestParameters: CreateDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationRead>): QueryConfig<T> {
    return createDestinationRaw(requestParameters, requestConfig);
}

/**
 * Delete the destination
 */
function deleteDestinationRaw<T>(requestParameters: DeleteDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.destinationIdRequestBody === null || requestParameters.destinationIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationIdRequestBody','Required parameter requestParameters.destinationIdRequestBody was null or undefined when calling deleteDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/delete`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationIdRequestBodyToJSON(requestParameters.destinationIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete the destination
*/
export function deleteDestination<T>(requestParameters: DeleteDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return deleteDestinationRaw(requestParameters, requestConfig);
}

/**
 * Get configured destination
 */
function getDestinationRaw<T>(requestParameters: GetDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationIdRequestBody === null || requestParameters.destinationIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationIdRequestBody','Required parameter requestParameters.destinationIdRequestBody was null or undefined when calling getDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/get`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationIdRequestBodyToJSON(requestParameters.destinationIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadFromJSON(body), text);
    }

    return config;
}

/**
* Get configured destination
*/
export function getDestination<T>(requestParameters: GetDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationRead>): QueryConfig<T> {
    return getDestinationRaw(requestParameters, requestConfig);
}

/**
 * List configured destinations for a workspace
 */
function listDestinationsForWorkspaceRaw<T>(requestParameters: ListDestinationsForWorkspaceRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationReadList> = {}): QueryConfig<T> {
    if (requestParameters.workspaceIdRequestBody === null || requestParameters.workspaceIdRequestBody === undefined) {
        throw new runtime.RequiredError('workspaceIdRequestBody','Required parameter requestParameters.workspaceIdRequestBody was null or undefined when calling listDestinationsForWorkspace.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/list`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || WorkspaceIdRequestBodyToJSON(requestParameters.workspaceIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadListFromJSON(body), text);
    }

    return config;
}

/**
* List configured destinations for a workspace
*/
export function listDestinationsForWorkspace<T>(requestParameters: ListDestinationsForWorkspaceRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationReadList>): QueryConfig<T> {
    return listDestinationsForWorkspaceRaw(requestParameters, requestConfig);
}

/**
 * Search destinations
 */
function searchDestinationsRaw<T>(requestParameters: SearchDestinationsRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationReadList> = {}): QueryConfig<T> {
    if (requestParameters.destinationSearch === null || requestParameters.destinationSearch === undefined) {
        throw new runtime.RequiredError('destinationSearch','Required parameter requestParameters.destinationSearch was null or undefined when calling searchDestinations.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/search`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationSearchToJSON(requestParameters.destinationSearch),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadListFromJSON(body), text);
    }

    return config;
}

/**
* Search destinations
*/
export function searchDestinations<T>(requestParameters: SearchDestinationsRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationReadList>): QueryConfig<T> {
    return searchDestinationsRaw(requestParameters, requestConfig);
}

/**
 * Update a destination
 */
function updateDestinationRaw<T>(requestParameters: UpdateDestinationRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationUpdate === null || requestParameters.destinationUpdate === undefined) {
        throw new runtime.RequiredError('destinationUpdate','Required parameter requestParameters.destinationUpdate was null or undefined when calling updateDestination.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destinations/update`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationUpdateToJSON(requestParameters.destinationUpdate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationReadFromJSON(body), text);
    }

    return config;
}

/**
* Update a destination
*/
export function updateDestination<T>(requestParameters: UpdateDestinationRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationRead>): QueryConfig<T> {
    return updateDestinationRaw(requestParameters, requestConfig);
}

