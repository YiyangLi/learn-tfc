// tslint:disable
/**
 * Airbyte Configuration API
 * Airbyte Configuration API [https://airbyte.io](https://airbyte.io).  This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.  Here are some conventions that this API follows: * All endpoints are http POST methods. * All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params. * The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`. * For all `update` methods, the whole object must be passed in, even the fields that did not change.  Change Management: * The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create` * Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests. * All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):   * Adding fields to request or response bodies.   * Adding new HTTP endpoints. * All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@airbyte.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CustomDestinationDefinitionCreate,
    CustomDestinationDefinitionCreateFromJSON,
    CustomDestinationDefinitionCreateToJSON,
    CustomDestinationDefinitionUpdate,
    CustomDestinationDefinitionUpdateFromJSON,
    CustomDestinationDefinitionUpdateToJSON,
    DestinationDefinitionCreate,
    DestinationDefinitionCreateFromJSON,
    DestinationDefinitionCreateToJSON,
    DestinationDefinitionIdRequestBody,
    DestinationDefinitionIdRequestBodyFromJSON,
    DestinationDefinitionIdRequestBodyToJSON,
    DestinationDefinitionIdWithWorkspaceId,
    DestinationDefinitionIdWithWorkspaceIdFromJSON,
    DestinationDefinitionIdWithWorkspaceIdToJSON,
    DestinationDefinitionRead,
    DestinationDefinitionReadFromJSON,
    DestinationDefinitionReadToJSON,
    DestinationDefinitionReadList,
    DestinationDefinitionReadListFromJSON,
    DestinationDefinitionReadListToJSON,
    DestinationDefinitionUpdate,
    DestinationDefinitionUpdateFromJSON,
    DestinationDefinitionUpdateToJSON,
    InvalidInputExceptionInfo,
    InvalidInputExceptionInfoFromJSON,
    InvalidInputExceptionInfoToJSON,
    NotFoundKnownExceptionInfo,
    NotFoundKnownExceptionInfoFromJSON,
    NotFoundKnownExceptionInfoToJSON,
    PrivateDestinationDefinitionRead,
    PrivateDestinationDefinitionReadFromJSON,
    PrivateDestinationDefinitionReadToJSON,
    PrivateDestinationDefinitionReadList,
    PrivateDestinationDefinitionReadListFromJSON,
    PrivateDestinationDefinitionReadListToJSON,
    WorkspaceIdRequestBody,
    WorkspaceIdRequestBodyFromJSON,
    WorkspaceIdRequestBodyToJSON,
} from '../models';

export interface CreateCustomDestinationDefinitionRequest {
    customDestinationDefinitionCreate?: CustomDestinationDefinitionCreate;
}

export interface CreateDestinationDefinitionRequest {
    destinationDefinitionCreate?: DestinationDefinitionCreate;
}

export interface DeleteCustomDestinationDefinitionRequest {
    destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId;
}

export interface DeleteDestinationDefinitionRequest {
    destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody;
}

export interface GetDestinationDefinitionRequest {
    destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody;
}

export interface GetDestinationDefinitionForWorkspaceRequest {
    destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId;
}

export interface GrantDestinationDefinitionToWorkspaceRequest {
    destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId;
}

export interface ListDestinationDefinitionsForWorkspaceRequest {
    workspaceIdRequestBody?: WorkspaceIdRequestBody;
}

export interface ListPrivateDestinationDefinitionsRequest {
    workspaceIdRequestBody?: WorkspaceIdRequestBody;
}

export interface RevokeDestinationDefinitionFromWorkspaceRequest {
    destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId;
}

export interface UpdateCustomDestinationDefinitionRequest {
    customDestinationDefinitionUpdate?: CustomDestinationDefinitionUpdate;
}

export interface UpdateDestinationDefinitionRequest {
    destinationDefinitionUpdate: DestinationDefinitionUpdate;
}


/**
 * Creates a custom destinationDefinition for the given workspace
 */
function createCustomDestinationDefinitionRaw<T>(requestParameters: CreateCustomDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/create_custom`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CustomDestinationDefinitionCreateToJSON(requestParameters.customDestinationDefinitionCreate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Creates a custom destinationDefinition for the given workspace
*/
export function createCustomDestinationDefinition<T>(requestParameters: CreateCustomDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return createCustomDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Creates a destinationsDefinition
 */
function createDestinationDefinitionRaw<T>(requestParameters: CreateDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/create`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionCreateToJSON(requestParameters.destinationDefinitionCreate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Creates a destinationsDefinition
*/
export function createDestinationDefinition<T>(requestParameters: CreateDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return createDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Delete a custom destination definition for the given workspace
 */
function deleteCustomDestinationDefinitionRaw<T>(requestParameters: DeleteCustomDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdWithWorkspaceId === null || requestParameters.destinationDefinitionIdWithWorkspaceId === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdWithWorkspaceId','Required parameter requestParameters.destinationDefinitionIdWithWorkspaceId was null or undefined when calling deleteCustomDestinationDefinition.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/delete_custom`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdWithWorkspaceIdToJSON(requestParameters.destinationDefinitionIdWithWorkspaceId),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete a custom destination definition for the given workspace
*/
export function deleteCustomDestinationDefinition<T>(requestParameters: DeleteCustomDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return deleteCustomDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Delete a destination definition
 */
function deleteDestinationDefinitionRaw<T>(requestParameters: DeleteDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdRequestBody === null || requestParameters.destinationDefinitionIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdRequestBody','Required parameter requestParameters.destinationDefinitionIdRequestBody was null or undefined when calling deleteDestinationDefinition.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/delete`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdRequestBodyToJSON(requestParameters.destinationDefinitionIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete a destination definition
*/
export function deleteDestinationDefinition<T>(requestParameters: DeleteDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return deleteDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Get destinationDefinition
 */
function getDestinationDefinitionRaw<T>(requestParameters: GetDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdRequestBody === null || requestParameters.destinationDefinitionIdRequestBody === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdRequestBody','Required parameter requestParameters.destinationDefinitionIdRequestBody was null or undefined when calling getDestinationDefinition.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/get`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdRequestBodyToJSON(requestParameters.destinationDefinitionIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Get destinationDefinition
*/
export function getDestinationDefinition<T>(requestParameters: GetDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return getDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Get a destinationDefinition that is configured for the given workspace
 */
function getDestinationDefinitionForWorkspaceRaw<T>(requestParameters: GetDestinationDefinitionForWorkspaceRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdWithWorkspaceId === null || requestParameters.destinationDefinitionIdWithWorkspaceId === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdWithWorkspaceId','Required parameter requestParameters.destinationDefinitionIdWithWorkspaceId was null or undefined when calling getDestinationDefinitionForWorkspace.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/get_for_workspace`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdWithWorkspaceIdToJSON(requestParameters.destinationDefinitionIdWithWorkspaceId),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Get a destinationDefinition that is configured for the given workspace
*/
export function getDestinationDefinitionForWorkspace<T>(requestParameters: GetDestinationDefinitionForWorkspaceRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return getDestinationDefinitionForWorkspaceRaw(requestParameters, requestConfig);
}

/**
 * grant a private, non-custom destinationDefinition to a given workspace
 */
function grantDestinationDefinitionToWorkspaceRaw<T>(requestParameters: GrantDestinationDefinitionToWorkspaceRequest, requestConfig: runtime.TypedQueryConfig<T, PrivateDestinationDefinitionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdWithWorkspaceId === null || requestParameters.destinationDefinitionIdWithWorkspaceId === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdWithWorkspaceId','Required parameter requestParameters.destinationDefinitionIdWithWorkspaceId was null or undefined when calling grantDestinationDefinitionToWorkspace.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/grant_definition`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdWithWorkspaceIdToJSON(requestParameters.destinationDefinitionIdWithWorkspaceId),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PrivateDestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* grant a private, non-custom destinationDefinition to a given workspace
*/
export function grantDestinationDefinitionToWorkspace<T>(requestParameters: GrantDestinationDefinitionToWorkspaceRequest, requestConfig?: runtime.TypedQueryConfig<T, PrivateDestinationDefinitionRead>): QueryConfig<T> {
    return grantDestinationDefinitionToWorkspaceRaw(requestParameters, requestConfig);
}

/**
 * List all the destinationDefinitions the current Airbyte deployment is configured to use
 */
function listDestinationDefinitionsRaw<T>( requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionReadList> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/list`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadListFromJSON(body), text);
    }

    return config;
}

/**
* List all the destinationDefinitions the current Airbyte deployment is configured to use
*/
export function listDestinationDefinitions<T>( requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionReadList>): QueryConfig<T> {
    return listDestinationDefinitionsRaw( requestConfig);
}

/**
 * List all the destinationDefinitions the given workspace is configured to use
 */
function listDestinationDefinitionsForWorkspaceRaw<T>(requestParameters: ListDestinationDefinitionsForWorkspaceRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionReadList> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/list_for_workspace`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || WorkspaceIdRequestBodyToJSON(requestParameters.workspaceIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadListFromJSON(body), text);
    }

    return config;
}

/**
* List all the destinationDefinitions the given workspace is configured to use
*/
export function listDestinationDefinitionsForWorkspace<T>(requestParameters: ListDestinationDefinitionsForWorkspaceRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionReadList>): QueryConfig<T> {
    return listDestinationDefinitionsForWorkspaceRaw(requestParameters, requestConfig);
}

/**
 * Guaranteed to retrieve the latest information on supported destinations.
 * List the latest destinationDefinitions Airbyte supports
 */
function listLatestDestinationDefinitionsRaw<T>( requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionReadList> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/list_latest`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadListFromJSON(body), text);
    }

    return config;
}

/**
* Guaranteed to retrieve the latest information on supported destinations.
* List the latest destinationDefinitions Airbyte supports
*/
export function listLatestDestinationDefinitions<T>( requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionReadList>): QueryConfig<T> {
    return listLatestDestinationDefinitionsRaw( requestConfig);
}

/**
 * List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
 */
function listPrivateDestinationDefinitionsRaw<T>(requestParameters: ListPrivateDestinationDefinitionsRequest, requestConfig: runtime.TypedQueryConfig<T, PrivateDestinationDefinitionReadList> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/list_private`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || WorkspaceIdRequestBodyToJSON(requestParameters.workspaceIdRequestBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PrivateDestinationDefinitionReadListFromJSON(body), text);
    }

    return config;
}

/**
* List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
*/
export function listPrivateDestinationDefinitions<T>(requestParameters: ListPrivateDestinationDefinitionsRequest, requestConfig?: runtime.TypedQueryConfig<T, PrivateDestinationDefinitionReadList>): QueryConfig<T> {
    return listPrivateDestinationDefinitionsRaw(requestParameters, requestConfig);
}

/**
 * revoke a grant to a private, non-custom destinationDefinition from a given workspace
 */
function revokeDestinationDefinitionFromWorkspaceRaw<T>(requestParameters: RevokeDestinationDefinitionFromWorkspaceRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionIdWithWorkspaceId === null || requestParameters.destinationDefinitionIdWithWorkspaceId === undefined) {
        throw new runtime.RequiredError('destinationDefinitionIdWithWorkspaceId','Required parameter requestParameters.destinationDefinitionIdWithWorkspaceId was null or undefined when calling revokeDestinationDefinitionFromWorkspace.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/revoke_definition`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionIdWithWorkspaceIdToJSON(requestParameters.destinationDefinitionIdWithWorkspaceId),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* revoke a grant to a private, non-custom destinationDefinition from a given workspace
*/
export function revokeDestinationDefinitionFromWorkspace<T>(requestParameters: RevokeDestinationDefinitionFromWorkspaceRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return revokeDestinationDefinitionFromWorkspaceRaw(requestParameters, requestConfig);
}

/**
 * Update a custom destinationDefinition for the given workspace
 */
function updateCustomDestinationDefinitionRaw<T>(requestParameters: UpdateCustomDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/update_custom`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CustomDestinationDefinitionUpdateToJSON(requestParameters.customDestinationDefinitionUpdate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Update a custom destinationDefinition for the given workspace
*/
export function updateCustomDestinationDefinition<T>(requestParameters: UpdateCustomDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return updateCustomDestinationDefinitionRaw(requestParameters, requestConfig);
}

/**
 * Update destinationDefinition
 */
function updateDestinationDefinitionRaw<T>(requestParameters: UpdateDestinationDefinitionRequest, requestConfig: runtime.TypedQueryConfig<T, DestinationDefinitionRead> = {}): QueryConfig<T> {
    if (requestParameters.destinationDefinitionUpdate === null || requestParameters.destinationDefinitionUpdate === undefined) {
        throw new runtime.RequiredError('destinationDefinitionUpdate','Required parameter requestParameters.destinationDefinitionUpdate was null or undefined when calling updateDestinationDefinition.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/destination_definitions/update`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || DestinationDefinitionUpdateToJSON(requestParameters.destinationDefinitionUpdate),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DestinationDefinitionReadFromJSON(body), text);
    }

    return config;
}

/**
* Update destinationDefinition
*/
export function updateDestinationDefinition<T>(requestParameters: UpdateDestinationDefinitionRequest, requestConfig?: runtime.TypedQueryConfig<T, DestinationDefinitionRead>): QueryConfig<T> {
    return updateDestinationDefinitionRaw(requestParameters, requestConfig);
}

