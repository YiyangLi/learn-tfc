/* tslint:disable */
/* eslint-disable */
/**
 * Airbyte Configuration API
 * Airbyte Configuration API [https://airbyte.io](https://airbyte.io).  This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.  Here are some conventions that this API follows: * All endpoints are http POST methods. * All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params. * The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`. * For all `update` methods, the whole object must be passed in, even the fields that did not change.  Change Management: * The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create` * Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests. * All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):   * Adding fields to request or response bodies.   * Adding new HTTP endpoints. * All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@airbyte.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
 * @export
 * @interface ActorDefinitionResourceRequirements
 */
export interface ActorDefinitionResourceRequirements {
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof ActorDefinitionResourceRequirements
     */
    'default'?: ResourceRequirements;
    /**
     * 
     * @type {Array<JobTypeResourceLimit>}
     * @memberof ActorDefinitionResourceRequirements
     */
    'jobSpecific'?: Array<JobTypeResourceLimit>;
}
/**
 * 
 * @export
 * @interface AdvancedAuth
 */
export interface AdvancedAuth {
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuth
     */
    'authFlowType'?: AdvancedAuthAuthFlowTypeEnum;
    /**
     * Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable.
     * @type {Array<string>}
     * @memberof AdvancedAuth
     */
    'predicateKey'?: Array<string>;
    /**
     * Value of the predicate_key fields for the advanced auth to be applicable.
     * @type {string}
     * @memberof AdvancedAuth
     */
    'predicateValue'?: string;
    /**
     * 
     * @type {OAuthConfigSpecification}
     * @memberof AdvancedAuth
     */
    'oauthConfigSpecification'?: OAuthConfigSpecification;
}

export const AdvancedAuthAuthFlowTypeEnum = {
    Oauth20: 'oauth2.0',
    Oauth10: 'oauth1.0'
} as const;

export type AdvancedAuthAuthFlowTypeEnum = typeof AdvancedAuthAuthFlowTypeEnum[keyof typeof AdvancedAuthAuthFlowTypeEnum];

/**
 * describes the available schema (catalog).
 * @export
 * @interface AirbyteCatalog
 */
export interface AirbyteCatalog {
    /**
     * 
     * @type {Array<AirbyteStreamAndConfiguration>}
     * @memberof AirbyteCatalog
     */
    'streams': Array<AirbyteStreamAndConfiguration>;
}
/**
 * the immutable schema defined by the source
 * @export
 * @interface AirbyteStream
 */
export interface AirbyteStream {
    /**
     * Stream\'s name.
     * @type {string}
     * @memberof AirbyteStream
     */
    'name': string;
    /**
     * Stream schema using Json Schema specs.
     * @type {object}
     * @memberof AirbyteStream
     */
    'jsonSchema'?: object;
    /**
     * 
     * @type {Array<SyncMode>}
     * @memberof AirbyteStream
     */
    'supportedSyncModes'?: Array<SyncMode>;
    /**
     * If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup.
     * @type {boolean}
     * @memberof AirbyteStream
     */
    'sourceDefinedCursor'?: boolean;
    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves.
     * @type {Array<string>}
     * @memberof AirbyteStream
     */
    'defaultCursorField'?: Array<string>;
    /**
     * If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves.
     * @type {Array<Array<string>>}
     * @memberof AirbyteStream
     */
    'sourceDefinedPrimaryKey'?: Array<Array<string>>;
    /**
     * Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to.
     * @type {string}
     * @memberof AirbyteStream
     */
    'namespace'?: string;
}
/**
 * each stream is split in two parts; the immutable schema from source and mutable configuration for destination
 * @export
 * @interface AirbyteStreamAndConfiguration
 */
export interface AirbyteStreamAndConfiguration {
    /**
     * 
     * @type {AirbyteStream}
     * @memberof AirbyteStreamAndConfiguration
     */
    'stream'?: AirbyteStream;
    /**
     * 
     * @type {AirbyteStreamConfiguration}
     * @memberof AirbyteStreamAndConfiguration
     */
    'config'?: AirbyteStreamConfiguration;
}
/**
 * the mutable part of the stream to configure the destination
 * @export
 * @interface AirbyteStreamConfiguration
 */
export interface AirbyteStreamConfiguration {
    /**
     * 
     * @type {SyncMode}
     * @memberof AirbyteStreamConfiguration
     */
    'syncMode': SyncMode;
    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored.
     * @type {Array<string>}
     * @memberof AirbyteStreamConfiguration
     */
    'cursorField'?: Array<string>;
    /**
     * 
     * @type {DestinationSyncMode}
     * @memberof AirbyteStreamConfiguration
     */
    'destinationSyncMode': DestinationSyncMode;
    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored.
     * @type {Array<Array<string>>}
     * @memberof AirbyteStreamConfiguration
     */
    'primaryKey'?: Array<Array<string>>;
    /**
     * Alias name to the stream to be used in the destination
     * @type {string}
     * @memberof AirbyteStreamConfiguration
     */
    'aliasName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AirbyteStreamConfiguration
     */
    'selected'?: boolean;
}
/**
 * Indicates where the error originated. If not set, the origin of error is not well known.
 * @export
 * @enum {string}
 */

export const AttemptFailureOrigin = {
    Source: 'source',
    Destination: 'destination',
    Replication: 'replication',
    Persistence: 'persistence',
    Normalization: 'normalization',
    Dbt: 'dbt',
    AirbytePlatform: 'airbyte_platform'
} as const;

export type AttemptFailureOrigin = typeof AttemptFailureOrigin[keyof typeof AttemptFailureOrigin];


/**
 * 
 * @export
 * @interface AttemptFailureReason
 */
export interface AttemptFailureReason {
    /**
     * 
     * @type {AttemptFailureOrigin}
     * @memberof AttemptFailureReason
     */
    'failureOrigin'?: AttemptFailureOrigin;
    /**
     * 
     * @type {AttemptFailureType}
     * @memberof AttemptFailureReason
     */
    'failureType'?: AttemptFailureType;
    /**
     * 
     * @type {string}
     * @memberof AttemptFailureReason
     */
    'externalMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptFailureReason
     */
    'internalMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptFailureReason
     */
    'stacktrace'?: string;
    /**
     * True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known.
     * @type {boolean}
     * @memberof AttemptFailureReason
     */
    'retryable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AttemptFailureReason
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface AttemptFailureSummary
 */
export interface AttemptFailureSummary {
    /**
     * 
     * @type {Array<AttemptFailureReason>}
     * @memberof AttemptFailureSummary
     */
    'failures': Array<AttemptFailureReason>;
    /**
     * True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown.
     * @type {boolean}
     * @memberof AttemptFailureSummary
     */
    'partialSuccess'?: boolean;
}
/**
 * Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
 * @export
 * @enum {string}
 */

export const AttemptFailureType = {
    ConfigError: 'config_error',
    SystemError: 'system_error',
    ManualCancellation: 'manual_cancellation'
} as const;

export type AttemptFailureType = typeof AttemptFailureType[keyof typeof AttemptFailureType];


/**
 * 
 * @export
 * @interface AttemptInfoRead
 */
export interface AttemptInfoRead {
    /**
     * 
     * @type {AttemptRead}
     * @memberof AttemptInfoRead
     */
    'attempt': AttemptRead;
    /**
     * 
     * @type {LogRead}
     * @memberof AttemptInfoRead
     */
    'logs': LogRead;
}
/**
 * 
 * @export
 * @interface AttemptRead
 */
export interface AttemptRead {
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'id': number;
    /**
     * 
     * @type {AttemptStatus}
     * @memberof AttemptRead
     */
    'status': AttemptStatus;
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'endedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'bytesSynced'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttemptRead
     */
    'recordsSynced'?: number;
    /**
     * 
     * @type {AttemptStats}
     * @memberof AttemptRead
     */
    'totalStats'?: AttemptStats;
    /**
     * 
     * @type {Array<AttemptStreamStats>}
     * @memberof AttemptRead
     */
    'streamStats'?: Array<AttemptStreamStats>;
    /**
     * 
     * @type {AttemptFailureSummary}
     * @memberof AttemptRead
     */
    'failureSummary'?: AttemptFailureSummary;
}
/**
 * 
 * @export
 * @interface AttemptStats
 */
export interface AttemptStats {
    /**
     * 
     * @type {number}
     * @memberof AttemptStats
     */
    'recordsEmitted'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttemptStats
     */
    'bytesEmitted'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttemptStats
     */
    'stateMessagesEmitted'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttemptStats
     */
    'recordsCommitted'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AttemptStatus = {
    Running: 'running',
    Failed: 'failed',
    Succeeded: 'succeeded'
} as const;

export type AttemptStatus = typeof AttemptStatus[keyof typeof AttemptStatus];


/**
 * 
 * @export
 * @interface AttemptStreamStats
 */
export interface AttemptStreamStats {
    /**
     * 
     * @type {string}
     * @memberof AttemptStreamStats
     */
    'streamName': string;
    /**
     * 
     * @type {AttemptStats}
     * @memberof AttemptStreamStats
     */
    'stats': AttemptStats;
}
/**
 * 
 * @export
 * @interface AuthSpecification
 */
export interface AuthSpecification {
    /**
     * 
     * @type {string}
     * @memberof AuthSpecification
     */
    'auth_type'?: AuthSpecificationAuthTypeEnum;
    /**
     * 
     * @type {OAuth2Specification}
     * @memberof AuthSpecification
     */
    'oauth2Specification'?: OAuth2Specification;
}

export const AuthSpecificationAuthTypeEnum = {
    Oauth20: 'oauth2.0'
} as const;

export type AuthSpecificationAuthTypeEnum = typeof AuthSpecificationAuthTypeEnum[keyof typeof AuthSpecificationAuthTypeEnum];

/**
 * Describes the difference between two Airbyte catalogs.
 * @export
 * @interface CatalogDiff
 */
export interface CatalogDiff {
    /**
     * list of stream transformations. order does not matter.
     * @type {Array<StreamTransform>}
     * @memberof CatalogDiff
     */
    'transforms': Array<StreamTransform>;
}
/**
 * 
 * @export
 * @interface CheckConnectionRead
 */
export interface CheckConnectionRead {
    /**
     * 
     * @type {string}
     * @memberof CheckConnectionRead
     */
    'status': CheckConnectionReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckConnectionRead
     */
    'message'?: string;
    /**
     * 
     * @type {SynchronousJobRead}
     * @memberof CheckConnectionRead
     */
    'jobInfo': SynchronousJobRead;
}

export const CheckConnectionReadStatusEnum = {
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type CheckConnectionReadStatusEnum = typeof CheckConnectionReadStatusEnum[keyof typeof CheckConnectionReadStatusEnum];

/**
 * 
 * @export
 * @interface CheckOperationRead
 */
export interface CheckOperationRead {
    /**
     * 
     * @type {string}
     * @memberof CheckOperationRead
     */
    'status': CheckOperationReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckOperationRead
     */
    'message'?: string;
}

export const CheckOperationReadStatusEnum = {
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type CheckOperationReadStatusEnum = typeof CheckOperationReadStatusEnum[keyof typeof CheckOperationReadStatusEnum];

/**
 * 
 * @export
 * @interface CompleteDestinationOAuthRequest
 */
export interface CompleteDestinationOAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof CompleteDestinationOAuthRequest
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteDestinationOAuthRequest
     */
    'workspaceId': string;
    /**
     * When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given.
     * @type {string}
     * @memberof CompleteDestinationOAuthRequest
     */
    'redirectUrl'?: string;
    /**
     * The query parameters present in the redirect URL after a user granted consent e.g auth code
     * @type {{ [key: string]: any; }}
     * @memberof CompleteDestinationOAuthRequest
     */
    'queryParams'?: { [key: string]: any; };
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof CompleteDestinationOAuthRequest
     */
    'oAuthInputConfiguration'?: any;
}
/**
 * 
 * @export
 * @interface CompleteSourceOauthRequest
 */
export interface CompleteSourceOauthRequest {
    /**
     * 
     * @type {string}
     * @memberof CompleteSourceOauthRequest
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSourceOauthRequest
     */
    'workspaceId': string;
    /**
     * When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given.
     * @type {string}
     * @memberof CompleteSourceOauthRequest
     */
    'redirectUrl'?: string;
    /**
     * The query parameters present in the redirect URL after a user granted consent e.g auth code
     * @type {{ [key: string]: any; }}
     * @memberof CompleteSourceOauthRequest
     */
    'queryParams'?: { [key: string]: any; };
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof CompleteSourceOauthRequest
     */
    'oAuthInputConfiguration'?: any;
}
/**
 * 
 * @export
 * @interface ConnectionCreate
 */
export interface ConnectionCreate {
    /**
     * Optional name of the connection
     * @type {string}
     * @memberof ConnectionCreate
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof ConnectionCreate
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof ConnectionCreate
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof ConnectionCreate
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionCreate
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionCreate
     */
    'destinationId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectionCreate
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof ConnectionCreate
     */
    'syncCatalog'?: AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof ConnectionCreate
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof ConnectionCreate
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof ConnectionCreate
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof ConnectionCreate
     */
    'sourceCatalogId'?: string;
}
/**
 * 
 * @export
 * @interface ConnectionIdRequestBody
 */
export interface ConnectionIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ConnectionIdRequestBody
     */
    'connectionId': string;
}
/**
 * 
 * @export
 * @interface ConnectionRead
 */
export interface ConnectionRead {
    /**
     * 
     * @type {string}
     * @memberof ConnectionRead
     */
    'connectionId': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionRead
     */
    'name': string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof ConnectionRead
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof ConnectionRead
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof ConnectionRead
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionRead
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionRead
     */
    'destinationId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectionRead
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof ConnectionRead
     */
    'syncCatalog': AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof ConnectionRead
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof ConnectionRead
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof ConnectionRead
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof ConnectionRead
     */
    'sourceCatalogId'?: string;
}
/**
 * 
 * @export
 * @interface ConnectionReadList
 */
export interface ConnectionReadList {
    /**
     * 
     * @type {Array<ConnectionRead>}
     * @memberof ConnectionReadList
     */
    'connections': Array<ConnectionRead>;
}
/**
 * if null, then no schedule is set.
 * @export
 * @interface ConnectionSchedule
 */
export interface ConnectionSchedule {
    /**
     * 
     * @type {number}
     * @memberof ConnectionSchedule
     */
    'units': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectionSchedule
     */
    'timeUnit': ConnectionScheduleTimeUnitEnum;
}

export const ConnectionScheduleTimeUnitEnum = {
    Minutes: 'minutes',
    Hours: 'hours',
    Days: 'days',
    Weeks: 'weeks',
    Months: 'months'
} as const;

export type ConnectionScheduleTimeUnitEnum = typeof ConnectionScheduleTimeUnitEnum[keyof typeof ConnectionScheduleTimeUnitEnum];

/**
 * 
 * @export
 * @interface ConnectionSearch
 */
export interface ConnectionSearch {
    /**
     * 
     * @type {string}
     * @memberof ConnectionSearch
     */
    'connectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionSearch
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof ConnectionSearch
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof ConnectionSearch
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof ConnectionSearch
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionSearch
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionSearch
     */
    'destinationId'?: string;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof ConnectionSearch
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof ConnectionSearch
     */
    'status'?: ConnectionStatus;
    /**
     * 
     * @type {SourceSearch}
     * @memberof ConnectionSearch
     */
    'source'?: SourceSearch;
    /**
     * 
     * @type {DestinationSearch}
     * @memberof ConnectionSearch
     */
    'destination'?: DestinationSearch;
}
/**
 * Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
 * @export
 * @interface ConnectionState
 */
export interface ConnectionState {
    /**
     * 
     * @type {ConnectionStateType}
     * @memberof ConnectionState
     */
    'stateType': ConnectionStateType;
    /**
     * 
     * @type {string}
     * @memberof ConnectionState
     */
    'connectionId': string;
    /**
     * 
     * @type {object}
     * @memberof ConnectionState
     */
    'state'?: object;
    /**
     * 
     * @type {Array<StreamState>}
     * @memberof ConnectionState
     */
    'streamState'?: Array<StreamState>;
    /**
     * 
     * @type {GlobalState}
     * @memberof ConnectionState
     */
    'globalState'?: GlobalState;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectionStateType = {
    Global: 'global',
    Stream: 'stream',
    Legacy: 'legacy',
    NotSet: 'not_set'
} as const;

export type ConnectionStateType = typeof ConnectionStateType[keyof typeof ConnectionStateType];


/**
 * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
 * @export
 * @enum {string}
 */

export const ConnectionStatus = {
    Active: 'active',
    Inactive: 'inactive',
    Deprecated: 'deprecated'
} as const;

export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];


/**
 * 
 * @export
 * @interface ConnectionUpdate
 */
export interface ConnectionUpdate {
    /**
     * 
     * @type {string}
     * @memberof ConnectionUpdate
     */
    'connectionId': string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof ConnectionUpdate
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof ConnectionUpdate
     */
    'namespaceFormat'?: string;
    /**
     * Name that will be set to this connection
     * @type {string}
     * @memberof ConnectionUpdate
     */
    'name'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof ConnectionUpdate
     */
    'prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConnectionUpdate
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof ConnectionUpdate
     */
    'syncCatalog': AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof ConnectionUpdate
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof ConnectionUpdate
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof ConnectionUpdate
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof ConnectionUpdate
     */
    'sourceCatalogId'?: string;
}
/**
 * 
 * @export
 * @interface CustomDestinationDefinitionCreate
 */
export interface CustomDestinationDefinitionCreate {
    /**
     * 
     * @type {string}
     * @memberof CustomDestinationDefinitionCreate
     */
    'workspaceId': string;
    /**
     * 
     * @type {DestinationDefinitionCreate}
     * @memberof CustomDestinationDefinitionCreate
     */
    'destinationDefinition': DestinationDefinitionCreate;
}
/**
 * 
 * @export
 * @interface CustomDestinationDefinitionUpdate
 */
export interface CustomDestinationDefinitionUpdate {
    /**
     * 
     * @type {string}
     * @memberof CustomDestinationDefinitionUpdate
     */
    'workspaceId': string;
    /**
     * 
     * @type {DestinationDefinitionUpdate}
     * @memberof CustomDestinationDefinitionUpdate
     */
    'destinationDefinition': DestinationDefinitionUpdate;
}
/**
 * 
 * @export
 * @interface CustomSourceDefinitionCreate
 */
export interface CustomSourceDefinitionCreate {
    /**
     * 
     * @type {string}
     * @memberof CustomSourceDefinitionCreate
     */
    'workspaceId': string;
    /**
     * 
     * @type {SourceDefinitionCreate}
     * @memberof CustomSourceDefinitionCreate
     */
    'sourceDefinition': SourceDefinitionCreate;
}
/**
 * 
 * @export
 * @interface CustomSourceDefinitionUpdate
 */
export interface CustomSourceDefinitionUpdate {
    /**
     * 
     * @type {string}
     * @memberof CustomSourceDefinitionUpdate
     */
    'workspaceId': string;
    /**
     * 
     * @type {SourceDefinitionUpdate}
     * @memberof CustomSourceDefinitionUpdate
     */
    'sourceDefinition': SourceDefinitionUpdate;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Object: 'object',
    Array: 'array'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * 
 * @export
 * @interface DbMigrationExecutionRead
 */
export interface DbMigrationExecutionRead {
    /**
     * 
     * @type {string}
     * @memberof DbMigrationExecutionRead
     */
    'initialVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbMigrationExecutionRead
     */
    'targetVersion'?: string;
    /**
     * 
     * @type {Array<DbMigrationRead>}
     * @memberof DbMigrationExecutionRead
     */
    'executedMigrations'?: Array<DbMigrationRead>;
}
/**
 * 
 * @export
 * @interface DbMigrationRead
 */
export interface DbMigrationRead {
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRead
     */
    'migrationType': string;
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRead
     */
    'migrationVersion': string;
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRead
     */
    'migrationDescription': string;
    /**
     * 
     * @type {DbMigrationState}
     * @memberof DbMigrationRead
     */
    'migrationState'?: DbMigrationState;
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRead
     */
    'migratedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof DbMigrationRead
     */
    'migratedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRead
     */
    'migrationScript'?: string;
}
/**
 * 
 * @export
 * @interface DbMigrationReadList
 */
export interface DbMigrationReadList {
    /**
     * 
     * @type {Array<DbMigrationRead>}
     * @memberof DbMigrationReadList
     */
    'migrations'?: Array<DbMigrationRead>;
}
/**
 * 
 * @export
 * @interface DbMigrationRequestBody
 */
export interface DbMigrationRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DbMigrationRequestBody
     */
    'database': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DbMigrationState = {
    Pending: 'pending',
    AboveTarget: 'above_target',
    BelowBaseline: 'below_baseline',
    Baseline: 'baseline',
    Ignored: 'ignored',
    MissingSuccess: 'missing_success',
    MissingFailed: 'missing_failed',
    Success: 'success',
    Undone: 'undone',
    Available: 'available',
    Failed: 'failed',
    OutOfOrder: 'out_of_order',
    FutureSuccess: 'future_success',
    FutureFailed: 'future_failed',
    Outdated: 'outdated',
    Superseded: 'superseded',
    Deleted: 'deleted'
} as const;

export type DbMigrationState = typeof DbMigrationState[keyof typeof DbMigrationState];


/**
 * 
 * @export
 * @interface DestinationCoreConfig
 */
export interface DestinationCoreConfig {
    /**
     * 
     * @type {string}
     * @memberof DestinationCoreConfig
     */
    'destinationDefinitionId': string;
    /**
     * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @type {any}
     * @memberof DestinationCoreConfig
     */
    'connectionConfiguration': any;
}
/**
 * 
 * @export
 * @interface DestinationCreate
 */
export interface DestinationCreate {
    /**
     * 
     * @type {string}
     * @memberof DestinationCreate
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationCreate
     */
    'destinationDefinitionId': string;
    /**
     * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @type {any}
     * @memberof DestinationCreate
     */
    'connectionConfiguration': any;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionCreate
 */
export interface DestinationDefinitionCreate {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionCreate
     */
    'dockerRepository': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionCreate
     */
    'dockerImageTag': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionCreate
     */
    'documentationUrl': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionCreate
     */
    'icon'?: string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof DestinationDefinitionCreate
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionIdRequestBody
 */
export interface DestinationDefinitionIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionIdRequestBody
     */
    'destinationDefinitionId': string;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionIdWithWorkspaceId
 */
export interface DestinationDefinitionIdWithWorkspaceId {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionIdWithWorkspaceId
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionIdWithWorkspaceId
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionRead
 */
export interface DestinationDefinitionRead {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'dockerRepository': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'dockerImageTag': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'documentationUrl': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'icon'?: string;
    /**
     * 
     * @type {ReleaseStage}
     * @memberof DestinationDefinitionRead
     */
    'releaseStage'?: ReleaseStage;
    /**
     * The date when this connector was first released, in yyyy-mm-dd format.
     * @type {string}
     * @memberof DestinationDefinitionRead
     */
    'releaseDate'?: string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof DestinationDefinitionRead
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionReadList
 */
export interface DestinationDefinitionReadList {
    /**
     * 
     * @type {Array<DestinationDefinitionRead>}
     * @memberof DestinationDefinitionReadList
     */
    'destinationDefinitions': Array<DestinationDefinitionRead>;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionSpecificationRead
 */
export interface DestinationDefinitionSpecificationRead {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'documentationUrl'?: string;
    /**
     * The specification for what values are required to configure the destinationDefinition.
     * @type {any}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'connectionSpecification'?: any;
    /**
     * 
     * @type {AuthSpecification}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'authSpecification'?: AuthSpecification;
    /**
     * 
     * @type {AdvancedAuth}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'advancedAuth'?: AdvancedAuth;
    /**
     * 
     * @type {SynchronousJobRead}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'jobInfo': SynchronousJobRead;
    /**
     * 
     * @type {Array<DestinationSyncMode>}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'supportedDestinationSyncModes'?: Array<DestinationSyncMode>;
    /**
     * 
     * @type {boolean}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'supportsDbt'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DestinationDefinitionSpecificationRead
     */
    'supportsNormalization'?: boolean;
}
/**
 * 
 * @export
 * @interface DestinationDefinitionUpdate
 */
export interface DestinationDefinitionUpdate {
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionUpdate
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationDefinitionUpdate
     */
    'dockerImageTag'?: string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof DestinationDefinitionUpdate
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * 
 * @export
 * @interface DestinationIdRequestBody
 */
export interface DestinationIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DestinationIdRequestBody
     */
    'destinationId': string;
}
/**
 * 
 * @export
 * @interface DestinationOauthConsentRequest
 */
export interface DestinationOauthConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof DestinationOauthConsentRequest
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationOauthConsentRequest
     */
    'workspaceId': string;
    /**
     * The url to redirect to after getting the user consent
     * @type {string}
     * @memberof DestinationOauthConsentRequest
     */
    'redirectUrl': string;
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof DestinationOauthConsentRequest
     */
    'oAuthInputConfiguration'?: any;
}
/**
 * 
 * @export
 * @interface DestinationRead
 */
export interface DestinationRead {
    /**
     * 
     * @type {string}
     * @memberof DestinationRead
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationRead
     */
    'destinationId': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationRead
     */
    'workspaceId': string;
    /**
     * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @type {any}
     * @memberof DestinationRead
     */
    'connectionConfiguration': any;
    /**
     * 
     * @type {string}
     * @memberof DestinationRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DestinationRead
     */
    'destinationName': string;
}
/**
 * 
 * @export
 * @interface DestinationReadList
 */
export interface DestinationReadList {
    /**
     * 
     * @type {Array<DestinationRead>}
     * @memberof DestinationReadList
     */
    'destinations': Array<DestinationRead>;
}
/**
 * 
 * @export
 * @interface DestinationSearch
 */
export interface DestinationSearch {
    /**
     * 
     * @type {string}
     * @memberof DestinationSearch
     */
    'destinationDefinitionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationSearch
     */
    'destinationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationSearch
     */
    'workspaceId'?: string;
    /**
     * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @type {any}
     * @memberof DestinationSearch
     */
    'connectionConfiguration'?: any;
    /**
     * 
     * @type {string}
     * @memberof DestinationSearch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationSearch
     */
    'destinationName'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DestinationSyncMode = {
    Append: 'append',
    Overwrite: 'overwrite',
    AppendDedup: 'append_dedup'
} as const;

export type DestinationSyncMode = typeof DestinationSyncMode[keyof typeof DestinationSyncMode];


/**
 * 
 * @export
 * @interface DestinationUpdate
 */
export interface DestinationUpdate {
    /**
     * 
     * @type {string}
     * @memberof DestinationUpdate
     */
    'destinationId': string;
    /**
     * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @type {any}
     * @memberof DestinationUpdate
     */
    'connectionConfiguration': any;
    /**
     * 
     * @type {string}
     * @memberof DestinationUpdate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface FieldNameAndSchema
 */
export interface FieldNameAndSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldNameAndSchema
     */
    'fieldName': Array<string>;
    /**
     * JSONSchema representation of the field
     * @type {{ [key: string]: any; }}
     * @memberof FieldNameAndSchema
     */
    'fieldSchema': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface FieldSchemaUpdate
 */
export interface FieldSchemaUpdate {
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldSchemaUpdate
     */
    'fieldName': Array<string>;
    /**
     * JSONSchema representation of the field
     * @type {{ [key: string]: any; }}
     * @memberof FieldSchemaUpdate
     */
    'oldSchema': { [key: string]: any; };
    /**
     * JSONSchema representation of the field
     * @type {{ [key: string]: any; }}
     * @memberof FieldSchemaUpdate
     */
    'newSchema': { [key: string]: any; };
}
/**
 * Describes the difference between two Streams.
 * @export
 * @interface FieldTransform
 */
export interface FieldTransform {
    /**
     * 
     * @type {string}
     * @memberof FieldTransform
     */
    'transformType': FieldTransformTransformTypeEnum;
    /**
     * 
     * @type {FieldNameAndSchema}
     * @memberof FieldTransform
     */
    'addField'?: FieldNameAndSchema;
    /**
     * 
     * @type {FieldNameAndSchema}
     * @memberof FieldTransform
     */
    'removeField'?: FieldNameAndSchema;
    /**
     * 
     * @type {FieldSchemaUpdate}
     * @memberof FieldTransform
     */
    'updateFieldSchema'?: FieldSchemaUpdate;
}

export const FieldTransformTransformTypeEnum = {
    AddField: 'add_field',
    RemoveField: 'remove_field',
    UpdateFieldSchema: 'update_field_schema'
} as const;

export type FieldTransformTransformTypeEnum = typeof FieldTransformTransformTypeEnum[keyof typeof FieldTransformTransformTypeEnum];

/**
 * 
 * @export
 * @interface GlobalState
 */
export interface GlobalState {
    /**
     * 
     * @type {object}
     * @memberof GlobalState
     */
    'shared_state'?: object;
    /**
     * 
     * @type {Array<StreamState>}
     * @memberof GlobalState
     */
    'streamStates': Array<StreamState>;
}
/**
 * 
 * @export
 * @interface HealthCheckRead
 */
export interface HealthCheckRead {
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckRead
     */
    'available': boolean;
}
/**
 * 
 * @export
 * @interface ImportRead
 */
export interface ImportRead {
    /**
     * 
     * @type {string}
     * @memberof ImportRead
     */
    'status': ImportReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ImportRead
     */
    'reason'?: string;
}

export const ImportReadStatusEnum = {
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type ImportReadStatusEnum = typeof ImportReadStatusEnum[keyof typeof ImportReadStatusEnum];

/**
 * 
 * @export
 * @interface ImportRequestBody
 */
export interface ImportRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ImportRequestBody
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ImportRequestBody
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface InvalidInputExceptionInfo
 */
export interface InvalidInputExceptionInfo {
    /**
     * 
     * @type {string}
     * @memberof InvalidInputExceptionInfo
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof InvalidInputExceptionInfo
     */
    'exceptionClassName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvalidInputExceptionInfo
     */
    'exceptionStack'?: Array<string>;
    /**
     * 
     * @type {Array<InvalidInputProperty>}
     * @memberof InvalidInputExceptionInfo
     */
    'validationErrors': Array<InvalidInputProperty>;
}
/**
 * 
 * @export
 * @interface InvalidInputProperty
 */
export interface InvalidInputProperty {
    /**
     * 
     * @type {string}
     * @memberof InvalidInputProperty
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof InvalidInputProperty
     */
    'invalidValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidInputProperty
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobConfigType = {
    CheckConnectionSource: 'check_connection_source',
    CheckConnectionDestination: 'check_connection_destination',
    DiscoverSchema: 'discover_schema',
    GetSpec: 'get_spec',
    Sync: 'sync',
    ResetConnection: 'reset_connection'
} as const;

export type JobConfigType = typeof JobConfigType[keyof typeof JobConfigType];


/**
 * 
 * @export
 * @interface JobDebugInfoRead
 */
export interface JobDebugInfoRead {
    /**
     * 
     * @type {JobDebugRead}
     * @memberof JobDebugInfoRead
     */
    'job': JobDebugRead;
    /**
     * 
     * @type {Array<AttemptInfoRead>}
     * @memberof JobDebugInfoRead
     */
    'attempts': Array<AttemptInfoRead>;
}
/**
 * 
 * @export
 * @interface JobDebugRead
 */
export interface JobDebugRead {
    /**
     * 
     * @type {number}
     * @memberof JobDebugRead
     */
    'id': number;
    /**
     * 
     * @type {JobConfigType}
     * @memberof JobDebugRead
     */
    'configType': JobConfigType;
    /**
     * 
     * @type {string}
     * @memberof JobDebugRead
     */
    'configId': string;
    /**
     * 
     * @type {JobStatus}
     * @memberof JobDebugRead
     */
    'status': JobStatus;
    /**
     * 
     * @type {string}
     * @memberof JobDebugRead
     */
    'airbyteVersion': string;
    /**
     * 
     * @type {SourceDefinitionRead}
     * @memberof JobDebugRead
     */
    'sourceDefinition': SourceDefinitionRead;
    /**
     * 
     * @type {DestinationDefinitionRead}
     * @memberof JobDebugRead
     */
    'destinationDefinition': DestinationDefinitionRead;
}
/**
 * 
 * @export
 * @interface JobIdRequestBody
 */
export interface JobIdRequestBody {
    /**
     * 
     * @type {number}
     * @memberof JobIdRequestBody
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface JobInfoRead
 */
export interface JobInfoRead {
    /**
     * 
     * @type {JobRead}
     * @memberof JobInfoRead
     */
    'job': JobRead;
    /**
     * 
     * @type {Array<AttemptInfoRead>}
     * @memberof JobInfoRead
     */
    'attempts': Array<AttemptInfoRead>;
}
/**
 * 
 * @export
 * @interface JobListRequestBody
 */
export interface JobListRequestBody {
    /**
     * 
     * @type {Array<JobConfigType>}
     * @memberof JobListRequestBody
     */
    'configTypes': Array<JobConfigType>;
    /**
     * 
     * @type {string}
     * @memberof JobListRequestBody
     */
    'configId': string;
    /**
     * 
     * @type {Pagination}
     * @memberof JobListRequestBody
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface JobRead
 */
export interface JobRead {
    /**
     * 
     * @type {number}
     * @memberof JobRead
     */
    'id': number;
    /**
     * 
     * @type {JobConfigType}
     * @memberof JobRead
     */
    'configType': JobConfigType;
    /**
     * 
     * @type {string}
     * @memberof JobRead
     */
    'configId': string;
    /**
     * 
     * @type {number}
     * @memberof JobRead
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof JobRead
     */
    'updatedAt': number;
    /**
     * 
     * @type {JobStatus}
     * @memberof JobRead
     */
    'status': JobStatus;
    /**
     * 
     * @type {Array<StreamDescriptor>}
     * @memberof JobRead
     */
    'streams'?: Array<StreamDescriptor>;
}
/**
 * 
 * @export
 * @interface JobReadList
 */
export interface JobReadList {
    /**
     * 
     * @type {Array<JobWithAttemptsRead>}
     * @memberof JobReadList
     */
    'jobs': Array<JobWithAttemptsRead>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Pending: 'pending',
    Running: 'running',
    Incomplete: 'incomplete',
    Failed: 'failed',
    Succeeded: 'succeeded',
    Cancelled: 'cancelled'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * enum that describes the different types of jobs that the platform runs.
 * @export
 * @enum {string}
 */

export const JobType = {
    GetSpec: 'get_spec',
    CheckConnection: 'check_connection',
    DiscoverSchema: 'discover_schema',
    Sync: 'sync',
    ResetConnection: 'reset_connection',
    ConnectionUpdater: 'connection_updater',
    Replicate: 'replicate'
} as const;

export type JobType = typeof JobType[keyof typeof JobType];


/**
 * sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
 * @export
 * @interface JobTypeResourceLimit
 */
export interface JobTypeResourceLimit {
    /**
     * 
     * @type {JobType}
     * @memberof JobTypeResourceLimit
     */
    'jobType': JobType;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof JobTypeResourceLimit
     */
    'resourceRequirements': ResourceRequirements;
}
/**
 * 
 * @export
 * @interface JobWithAttemptsRead
 */
export interface JobWithAttemptsRead {
    /**
     * 
     * @type {JobRead}
     * @memberof JobWithAttemptsRead
     */
    'job'?: JobRead;
    /**
     * 
     * @type {Array<AttemptRead>}
     * @memberof JobWithAttemptsRead
     */
    'attempts'?: Array<AttemptRead>;
}
/**
 * 
 * @export
 * @interface KnownExceptionInfo
 */
export interface KnownExceptionInfo {
    /**
     * 
     * @type {string}
     * @memberof KnownExceptionInfo
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof KnownExceptionInfo
     */
    'exceptionClassName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KnownExceptionInfo
     */
    'exceptionStack'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KnownExceptionInfo
     */
    'rootCauseExceptionClassName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KnownExceptionInfo
     */
    'rootCauseExceptionStack'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LogRead
 */
export interface LogRead {
    /**
     * 
     * @type {Array<string>}
     * @memberof LogRead
     */
    'logLines': Array<string>;
}
/**
 * type/source of logs produced
 * @export
 * @enum {string}
 */

export const LogType = {
    Server: 'server',
    Scheduler: 'scheduler'
} as const;

export type LogType = typeof LogType[keyof typeof LogType];


/**
 * 
 * @export
 * @interface LogsRequestBody
 */
export interface LogsRequestBody {
    /**
     * 
     * @type {LogType}
     * @memberof LogsRequestBody
     */
    'logType': LogType;
}
/**
 * Method used for computing final namespace in destination
 * @export
 * @enum {string}
 */

export const NamespaceDefinitionType = {
    Source: 'source',
    Destination: 'destination',
    Customformat: 'customformat'
} as const;

export type NamespaceDefinitionType = typeof NamespaceDefinitionType[keyof typeof NamespaceDefinitionType];


/**
 * 
 * @export
 * @interface NotFoundKnownExceptionInfo
 */
export interface NotFoundKnownExceptionInfo {
    /**
     * 
     * @type {string}
     * @memberof NotFoundKnownExceptionInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundKnownExceptionInfo
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundKnownExceptionInfo
     */
    'exceptionClassName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotFoundKnownExceptionInfo
     */
    'exceptionStack'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NotFoundKnownExceptionInfo
     */
    'rootCauseExceptionClassName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotFoundKnownExceptionInfo
     */
    'rootCauseExceptionStack'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {NotificationType}
     * @memberof Notification
     */
    'notificationType': NotificationType;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'sendOnSuccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'sendOnFailure': boolean;
    /**
     * 
     * @type {SlackNotificationConfiguration}
     * @memberof Notification
     */
    'slackConfiguration'?: SlackNotificationConfiguration;
    /**
     * 
     * @type {object}
     * @memberof Notification
     */
    'customerioConfiguration'?: object;
}
/**
 * 
 * @export
 * @interface NotificationRead
 */
export interface NotificationRead {
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'status': NotificationReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'message'?: string;
}

export const NotificationReadStatusEnum = {
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type NotificationReadStatusEnum = typeof NotificationReadStatusEnum[keyof typeof NotificationReadStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationType = {
    Slack: 'slack',
    Customerio: 'customerio'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * An object containing any metadata needed to describe this connector\'s Oauth flow
 * @export
 * @interface OAuth2Specification
 */
export interface OAuth2Specification {
    /**
     * A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification. Examples: if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {\'credentials\': {\'app_id\' etc...}, rootObject=[\'credentials\'] If they were inside a oneOf {\'switch\': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=[\'switch\', 0] 
     * @type {Array<any>}
     * @memberof OAuth2Specification
     */
    'rootObject': Array<any>;
    /**
     * Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params \'app_secret\', \'app_id\' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [[\'app_secret\'], [\'app_id\']] If they are nested inside an object called \'auth_params\' then this array would be [[\'auth_params\', \'app_secret\'], [\'auth_params\', \'app_id\']]
     * @type {Array<Array<string>>}
     * @memberof OAuth2Specification
     */
    'oauthFlowInitParameters': Array<Array<string>>;
    /**
     * Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field.
     * @type {Array<Array<string>>}
     * @memberof OAuth2Specification
     */
    'oauthFlowOutputParameters': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface OAuthConfigSpecification
 */
export interface OAuthConfigSpecification {
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof OAuthConfigSpecification
     */
    'oauthUserInputFromConnectorConfigSpecification'?: any;
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof OAuthConfigSpecification
     */
    'completeOAuthOutputSpecification'?: any;
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof OAuthConfigSpecification
     */
    'completeOAuthServerInputSpecification'?: any;
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof OAuthConfigSpecification
     */
    'completeOAuthServerOutputSpecification'?: any;
}
/**
 * 
 * @export
 * @interface OAuthConsentRead
 */
export interface OAuthConsentRead {
    /**
     * 
     * @type {string}
     * @memberof OAuthConsentRead
     */
    'consentUrl': string;
}
/**
 * 
 * @export
 * @interface OperationCreate
 */
export interface OperationCreate {
    /**
     * 
     * @type {string}
     * @memberof OperationCreate
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof OperationCreate
     */
    'name': string;
    /**
     * 
     * @type {OperatorConfiguration}
     * @memberof OperationCreate
     */
    'operatorConfiguration': OperatorConfiguration;
}
/**
 * 
 * @export
 * @interface OperationIdRequestBody
 */
export interface OperationIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof OperationIdRequestBody
     */
    'operationId': string;
}
/**
 * 
 * @export
 * @interface OperationRead
 */
export interface OperationRead {
    /**
     * 
     * @type {string}
     * @memberof OperationRead
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof OperationRead
     */
    'operationId': string;
    /**
     * 
     * @type {string}
     * @memberof OperationRead
     */
    'name': string;
    /**
     * 
     * @type {OperatorConfiguration}
     * @memberof OperationRead
     */
    'operatorConfiguration': OperatorConfiguration;
}
/**
 * 
 * @export
 * @interface OperationReadList
 */
export interface OperationReadList {
    /**
     * 
     * @type {Array<OperationRead>}
     * @memberof OperationReadList
     */
    'operations': Array<OperationRead>;
}
/**
 * 
 * @export
 * @interface OperationUpdate
 */
export interface OperationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OperationUpdate
     */
    'operationId': string;
    /**
     * 
     * @type {string}
     * @memberof OperationUpdate
     */
    'name': string;
    /**
     * 
     * @type {OperatorConfiguration}
     * @memberof OperationUpdate
     */
    'operatorConfiguration': OperatorConfiguration;
}
/**
 * 
 * @export
 * @interface OperatorConfiguration
 */
export interface OperatorConfiguration {
    /**
     * 
     * @type {OperatorType}
     * @memberof OperatorConfiguration
     */
    'operatorType': OperatorType;
    /**
     * 
     * @type {OperatorNormalization}
     * @memberof OperatorConfiguration
     */
    'normalization'?: OperatorNormalization;
    /**
     * 
     * @type {OperatorDbt}
     * @memberof OperatorConfiguration
     */
    'dbt'?: OperatorDbt;
}
/**
 * 
 * @export
 * @interface OperatorDbt
 */
export interface OperatorDbt {
    /**
     * 
     * @type {string}
     * @memberof OperatorDbt
     */
    'gitRepoUrl': string;
    /**
     * 
     * @type {string}
     * @memberof OperatorDbt
     */
    'gitRepoBranch'?: string;
    /**
     * 
     * @type {string}
     * @memberof OperatorDbt
     */
    'dockerImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof OperatorDbt
     */
    'dbtArguments'?: string;
}
/**
 * 
 * @export
 * @interface OperatorNormalization
 */
export interface OperatorNormalization {
    /**
     * 
     * @type {string}
     * @memberof OperatorNormalization
     */
    'option'?: OperatorNormalizationOptionEnum;
}

export const OperatorNormalizationOptionEnum = {
    Basic: 'basic'
} as const;

export type OperatorNormalizationOptionEnum = typeof OperatorNormalizationOptionEnum[keyof typeof OperatorNormalizationOptionEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const OperatorType = {
    Normalization: 'normalization',
    Dbt: 'dbt'
} as const;

export type OperatorType = typeof OperatorType[keyof typeof OperatorType];


/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'rowOffset'?: number;
}
/**
 * 
 * @export
 * @interface PrivateDestinationDefinitionRead
 */
export interface PrivateDestinationDefinitionRead {
    /**
     * 
     * @type {DestinationDefinitionRead}
     * @memberof PrivateDestinationDefinitionRead
     */
    'destinationDefinition': DestinationDefinitionRead;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateDestinationDefinitionRead
     */
    'granted': boolean;
}
/**
 * 
 * @export
 * @interface PrivateDestinationDefinitionReadList
 */
export interface PrivateDestinationDefinitionReadList {
    /**
     * 
     * @type {Array<PrivateDestinationDefinitionRead>}
     * @memberof PrivateDestinationDefinitionReadList
     */
    'destinationDefinitions': Array<PrivateDestinationDefinitionRead>;
}
/**
 * 
 * @export
 * @interface PrivateSourceDefinitionRead
 */
export interface PrivateSourceDefinitionRead {
    /**
     * 
     * @type {SourceDefinitionRead}
     * @memberof PrivateSourceDefinitionRead
     */
    'sourceDefinition': SourceDefinitionRead;
    /**
     * 
     * @type {boolean}
     * @memberof PrivateSourceDefinitionRead
     */
    'granted': boolean;
}
/**
 * 
 * @export
 * @interface PrivateSourceDefinitionReadList
 */
export interface PrivateSourceDefinitionReadList {
    /**
     * 
     * @type {Array<PrivateSourceDefinitionRead>}
     * @memberof PrivateSourceDefinitionReadList
     */
    'sourceDefinitions': Array<PrivateSourceDefinitionRead>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReleaseStage = {
    Alpha: 'alpha',
    Beta: 'beta',
    GenerallyAvailable: 'generally_available',
    Custom: 'custom'
} as const;

export type ReleaseStage = typeof ReleaseStage[keyof typeof ReleaseStage];


/**
 * optional resource requirements to run workers (blank for unbounded allocations)
 * @export
 * @interface ResourceRequirements
 */
export interface ResourceRequirements {
    /**
     * 
     * @type {string}
     * @memberof ResourceRequirements
     */
    'cpu_request'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceRequirements
     */
    'cpu_limit'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceRequirements
     */
    'memory_request'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceRequirements
     */
    'memory_limit'?: string;
}
/**
 * 
 * @export
 * @interface SetInstancewideDestinationOauthParamsRequestBody
 */
export interface SetInstancewideDestinationOauthParamsRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SetInstancewideDestinationOauthParamsRequestBody
     */
    'destinationDefinitionId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SetInstancewideDestinationOauthParamsRequestBody
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SetInstancewideSourceOauthParamsRequestBody
 */
export interface SetInstancewideSourceOauthParamsRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SetInstancewideSourceOauthParamsRequestBody
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SetInstancewideSourceOauthParamsRequestBody
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SlackNotificationConfiguration
 */
export interface SlackNotificationConfiguration {
    /**
     * 
     * @type {string}
     * @memberof SlackNotificationConfiguration
     */
    'webhook': string;
}
/**
 * 
 * @export
 * @interface SlugRequestBody
 */
export interface SlugRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SlugRequestBody
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface SourceCoreConfig
 */
export interface SourceCoreConfig {
    /**
     * 
     * @type {string}
     * @memberof SourceCoreConfig
     */
    'sourceDefinitionId': string;
    /**
     * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @type {any}
     * @memberof SourceCoreConfig
     */
    'connectionConfiguration': any;
}
/**
 * 
 * @export
 * @interface SourceCreate
 */
export interface SourceCreate {
    /**
     * 
     * @type {string}
     * @memberof SourceCreate
     */
    'sourceDefinitionId': string;
    /**
     * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @type {any}
     * @memberof SourceCreate
     */
    'connectionConfiguration': any;
    /**
     * 
     * @type {string}
     * @memberof SourceCreate
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceCreate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SourceDefinitionCreate
 */
export interface SourceDefinitionCreate {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionCreate
     */
    'dockerRepository': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionCreate
     */
    'dockerImageTag': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionCreate
     */
    'documentationUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionCreate
     */
    'icon'?: string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof SourceDefinitionCreate
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * 
 * @export
 * @interface SourceDefinitionIdRequestBody
 */
export interface SourceDefinitionIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionIdRequestBody
     */
    'sourceDefinitionId': string;
}
/**
 * 
 * @export
 * @interface SourceDefinitionIdWithWorkspaceId
 */
export interface SourceDefinitionIdWithWorkspaceId {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionIdWithWorkspaceId
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionIdWithWorkspaceId
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface SourceDefinitionRead
 */
export interface SourceDefinitionRead {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'dockerRepository': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'dockerImageTag': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'documentationUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'icon'?: string;
    /**
     * 
     * @type {ReleaseStage}
     * @memberof SourceDefinitionRead
     */
    'releaseStage'?: ReleaseStage;
    /**
     * The date when this connector was first released, in yyyy-mm-dd format.
     * @type {string}
     * @memberof SourceDefinitionRead
     */
    'releaseDate'?: string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof SourceDefinitionRead
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * 
 * @export
 * @interface SourceDefinitionReadList
 */
export interface SourceDefinitionReadList {
    /**
     * 
     * @type {Array<SourceDefinitionRead>}
     * @memberof SourceDefinitionReadList
     */
    'sourceDefinitions': Array<SourceDefinitionRead>;
}
/**
 * 
 * @export
 * @interface SourceDefinitionSpecificationRead
 */
export interface SourceDefinitionSpecificationRead {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionSpecificationRead
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionSpecificationRead
     */
    'documentationUrl'?: string;
    /**
     * The specification for what values are required to configure the sourceDefinition.
     * @type {object}
     * @memberof SourceDefinitionSpecificationRead
     */
    'connectionSpecification'?: object;
    /**
     * 
     * @type {AuthSpecification}
     * @memberof SourceDefinitionSpecificationRead
     */
    'authSpecification'?: AuthSpecification;
    /**
     * 
     * @type {AdvancedAuth}
     * @memberof SourceDefinitionSpecificationRead
     */
    'advancedAuth'?: AdvancedAuth;
    /**
     * 
     * @type {SynchronousJobRead}
     * @memberof SourceDefinitionSpecificationRead
     */
    'jobInfo': SynchronousJobRead;
}
/**
 * Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
 * @export
 * @interface SourceDefinitionUpdate
 */
export interface SourceDefinitionUpdate {
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionUpdate
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDefinitionUpdate
     */
    'dockerImageTag': string;
    /**
     * 
     * @type {ActorDefinitionResourceRequirements}
     * @memberof SourceDefinitionUpdate
     */
    'resourceRequirements'?: ActorDefinitionResourceRequirements;
}
/**
 * Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
 * @export
 * @interface SourceDiscoverSchemaRead
 */
export interface SourceDiscoverSchemaRead {
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof SourceDiscoverSchemaRead
     */
    'catalog'?: AirbyteCatalog;
    /**
     * 
     * @type {SynchronousJobRead}
     * @memberof SourceDiscoverSchemaRead
     */
    'jobInfo': SynchronousJobRead;
    /**
     * 
     * @type {string}
     * @memberof SourceDiscoverSchemaRead
     */
    'catalogId'?: string;
}
/**
 * 
 * @export
 * @interface SourceDiscoverSchemaRequestBody
 */
export interface SourceDiscoverSchemaRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SourceDiscoverSchemaRequestBody
     */
    'sourceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof SourceDiscoverSchemaRequestBody
     */
    'disable_cache'?: boolean;
}
/**
 * 
 * @export
 * @interface SourceIdRequestBody
 */
export interface SourceIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SourceIdRequestBody
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface SourceOauthConsentRequest
 */
export interface SourceOauthConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof SourceOauthConsentRequest
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceOauthConsentRequest
     */
    'workspaceId': string;
    /**
     * The url to redirect to after getting the user consent
     * @type {string}
     * @memberof SourceOauthConsentRequest
     */
    'redirectUrl': string;
    /**
     * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
     * @type {any}
     * @memberof SourceOauthConsentRequest
     */
    'oAuthInputConfiguration'?: any;
}
/**
 * 
 * @export
 * @interface SourceRead
 */
export interface SourceRead {
    /**
     * 
     * @type {string}
     * @memberof SourceRead
     */
    'sourceDefinitionId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceRead
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceRead
     */
    'workspaceId': string;
    /**
     * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @type {any}
     * @memberof SourceRead
     */
    'connectionConfiguration': any;
    /**
     * 
     * @type {string}
     * @memberof SourceRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceRead
     */
    'sourceName': string;
}
/**
 * 
 * @export
 * @interface SourceReadList
 */
export interface SourceReadList {
    /**
     * 
     * @type {Array<SourceRead>}
     * @memberof SourceReadList
     */
    'sources': Array<SourceRead>;
}
/**
 * 
 * @export
 * @interface SourceSearch
 */
export interface SourceSearch {
    /**
     * 
     * @type {string}
     * @memberof SourceSearch
     */
    'sourceDefinitionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSearch
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSearch
     */
    'workspaceId'?: string;
    /**
     * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @type {any}
     * @memberof SourceSearch
     */
    'connectionConfiguration'?: any;
    /**
     * 
     * @type {string}
     * @memberof SourceSearch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSearch
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface SourceUpdate
 */
export interface SourceUpdate {
    /**
     * 
     * @type {string}
     * @memberof SourceUpdate
     */
    'sourceId': string;
    /**
     * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @type {any}
     * @memberof SourceUpdate
     */
    'connectionConfiguration': any;
    /**
     * 
     * @type {string}
     * @memberof SourceUpdate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StreamDescriptor
 */
export interface StreamDescriptor {
    /**
     * 
     * @type {string}
     * @memberof StreamDescriptor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StreamDescriptor
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface StreamState
 */
export interface StreamState {
    /**
     * 
     * @type {StreamDescriptor}
     * @memberof StreamState
     */
    'streamDescriptor': StreamDescriptor;
    /**
     * 
     * @type {object}
     * @memberof StreamState
     */
    'streamState'?: object;
}
/**
 * 
 * @export
 * @interface StreamTransform
 */
export interface StreamTransform {
    /**
     * 
     * @type {string}
     * @memberof StreamTransform
     */
    'transformType': StreamTransformTransformTypeEnum;
    /**
     * 
     * @type {StreamDescriptor}
     * @memberof StreamTransform
     */
    'addStream'?: StreamDescriptor;
    /**
     * 
     * @type {StreamDescriptor}
     * @memberof StreamTransform
     */
    'removeStream'?: StreamDescriptor;
    /**
     * list of field transformations. order does not matter.
     * @type {Array<FieldTransform>}
     * @memberof StreamTransform
     */
    'updateStream'?: Array<FieldTransform>;
}

export const StreamTransformTransformTypeEnum = {
    AddStream: 'add_stream',
    RemoveStream: 'remove_stream',
    UpdateStream: 'update_stream'
} as const;

export type StreamTransformTransformTypeEnum = typeof StreamTransformTransformTypeEnum[keyof typeof StreamTransformTransformTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const SyncMode = {
    FullRefresh: 'full_refresh',
    Incremental: 'incremental'
} as const;

export type SyncMode = typeof SyncMode[keyof typeof SyncMode];


/**
 * 
 * @export
 * @interface SynchronousJobRead
 */
export interface SynchronousJobRead {
    /**
     * 
     * @type {string}
     * @memberof SynchronousJobRead
     */
    'id': string;
    /**
     * 
     * @type {JobConfigType}
     * @memberof SynchronousJobRead
     */
    'configType': JobConfigType;
    /**
     * only present if a config id was provided.
     * @type {string}
     * @memberof SynchronousJobRead
     */
    'configId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SynchronousJobRead
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof SynchronousJobRead
     */
    'endedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof SynchronousJobRead
     */
    'succeeded': boolean;
    /**
     * 
     * @type {LogRead}
     * @memberof SynchronousJobRead
     */
    'logs'?: LogRead;
}
/**
 * 
 * @export
 * @interface UploadRead
 */
export interface UploadRead {
    /**
     * 
     * @type {string}
     * @memberof UploadRead
     */
    'status': UploadReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UploadRead
     */
    'resourceId'?: string;
}

export const UploadReadStatusEnum = {
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type UploadReadStatusEnum = typeof UploadReadStatusEnum[keyof typeof UploadReadStatusEnum];

/**
 * 
 * @export
 * @interface WebBackendConnectionCreate
 */
export interface WebBackendConnectionCreate {
    /**
     * Optional name of the connection
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof WebBackendConnectionCreate
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'destinationId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebBackendConnectionCreate
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof WebBackendConnectionCreate
     */
    'syncCatalog'?: AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof WebBackendConnectionCreate
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof WebBackendConnectionCreate
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof WebBackendConnectionCreate
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {Array<OperationCreate>}
     * @memberof WebBackendConnectionCreate
     */
    'operations'?: Array<OperationCreate>;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionCreate
     */
    'sourceCatalogId'?: string;
}
/**
 * 
 * @export
 * @interface WebBackendConnectionRead
 */
export interface WebBackendConnectionRead {
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'connectionId': string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'name': string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof WebBackendConnectionRead
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'destinationId': string;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof WebBackendConnectionRead
     */
    'syncCatalog': AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof WebBackendConnectionRead
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof WebBackendConnectionRead
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebBackendConnectionRead
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {SourceRead}
     * @memberof WebBackendConnectionRead
     */
    'source': SourceRead;
    /**
     * 
     * @type {DestinationRead}
     * @memberof WebBackendConnectionRead
     */
    'destination': DestinationRead;
    /**
     * 
     * @type {Array<OperationRead>}
     * @memberof WebBackendConnectionRead
     */
    'operations'?: Array<OperationRead>;
    /**
     * epoch time of the latest sync job. null if no sync job has taken place.
     * @type {number}
     * @memberof WebBackendConnectionRead
     */
    'latestSyncJobCreatedAt'?: number;
    /**
     * 
     * @type {JobStatus}
     * @memberof WebBackendConnectionRead
     */
    'latestSyncJobStatus'?: JobStatus;
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendConnectionRead
     */
    'isSyncing': boolean;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof WebBackendConnectionRead
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRead
     */
    'catalogId'?: string;
    /**
     * 
     * @type {CatalogDiff}
     * @memberof WebBackendConnectionRead
     */
    'catalogDiff'?: CatalogDiff;
}
/**
 * 
 * @export
 * @interface WebBackendConnectionReadList
 */
export interface WebBackendConnectionReadList {
    /**
     * 
     * @type {Array<WebBackendConnectionRead>}
     * @memberof WebBackendConnectionReadList
     */
    'connections': Array<WebBackendConnectionRead>;
}
/**
 * 
 * @export
 * @interface WebBackendConnectionRequestBody
 */
export interface WebBackendConnectionRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendConnectionRequestBody
     */
    'withRefreshedCatalog'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionRequestBody
     */
    'connectionId': string;
}
/**
 * 
 * @export
 * @interface WebBackendConnectionSearch
 */
export interface WebBackendConnectionSearch {
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'connectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'name'?: string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof WebBackendConnectionSearch
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionSearch
     */
    'destinationId'?: string;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof WebBackendConnectionSearch
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof WebBackendConnectionSearch
     */
    'status'?: ConnectionStatus;
    /**
     * 
     * @type {SourceSearch}
     * @memberof WebBackendConnectionSearch
     */
    'source'?: SourceSearch;
    /**
     * 
     * @type {DestinationSearch}
     * @memberof WebBackendConnectionSearch
     */
    'destination'?: DestinationSearch;
}
/**
 * 
 * @export
 * @interface WebBackendConnectionUpdate
 */
export interface WebBackendConnectionUpdate {
    /**
     * Name that will be set to the connection
     * @type {string}
     * @memberof WebBackendConnectionUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionUpdate
     */
    'connectionId': string;
    /**
     * 
     * @type {NamespaceDefinitionType}
     * @memberof WebBackendConnectionUpdate
     */
    'namespaceDefinition'?: NamespaceDefinitionType;
    /**
     * Used when namespaceDefinition is \'customformat\'. If blank then behaves like namespaceDefinition = \'destination\'. If \"${SOURCE_NAMESPACE}\" then behaves like namespaceDefinition = \'source\'.
     * @type {string}
     * @memberof WebBackendConnectionUpdate
     */
    'namespaceFormat'?: string;
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     * @type {string}
     * @memberof WebBackendConnectionUpdate
     */
    'prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebBackendConnectionUpdate
     */
    'operationIds'?: Array<string>;
    /**
     * 
     * @type {AirbyteCatalog}
     * @memberof WebBackendConnectionUpdate
     */
    'syncCatalog': AirbyteCatalog;
    /**
     * 
     * @type {ConnectionSchedule}
     * @memberof WebBackendConnectionUpdate
     */
    'schedule'?: ConnectionSchedule;
    /**
     * 
     * @type {ConnectionStatus}
     * @memberof WebBackendConnectionUpdate
     */
    'status': ConnectionStatus;
    /**
     * 
     * @type {ResourceRequirements}
     * @memberof WebBackendConnectionUpdate
     */
    'resourceRequirements'?: ResourceRequirements;
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendConnectionUpdate
     */
    'withRefreshedCatalog'?: boolean;
    /**
     * 
     * @type {Array<WebBackendOperationCreateOrUpdate>}
     * @memberof WebBackendConnectionUpdate
     */
    'operations'?: Array<WebBackendOperationCreateOrUpdate>;
    /**
     * 
     * @type {string}
     * @memberof WebBackendConnectionUpdate
     */
    'sourceCatalogId'?: string;
}
/**
 * 
 * @export
 * @interface WebBackendOperationCreateOrUpdate
 */
export interface WebBackendOperationCreateOrUpdate {
    /**
     * 
     * @type {string}
     * @memberof WebBackendOperationCreateOrUpdate
     */
    'operationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendOperationCreateOrUpdate
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WebBackendOperationCreateOrUpdate
     */
    'name': string;
    /**
     * 
     * @type {OperatorConfiguration}
     * @memberof WebBackendOperationCreateOrUpdate
     */
    'operatorConfiguration': OperatorConfiguration;
}
/**
 * 
 * @export
 * @interface WebBackendWorkspaceState
 */
export interface WebBackendWorkspaceState {
    /**
     * 
     * @type {string}
     * @memberof WebBackendWorkspaceState
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface WebBackendWorkspaceStateResult
 */
export interface WebBackendWorkspaceStateResult {
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendWorkspaceStateResult
     */
    'hasConnections': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendWorkspaceStateResult
     */
    'hasSources': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebBackendWorkspaceStateResult
     */
    'hasDestinations': boolean;
}
/**
 * 
 * @export
 * @interface WorkspaceCreate
 */
export interface WorkspaceCreate {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceCreate
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceCreate
     */
    'anonymousDataCollection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceCreate
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceCreate
     */
    'news'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceCreate
     */
    'securityUpdates'?: boolean;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof WorkspaceCreate
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceCreate
     */
    'displaySetupWizard'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkspaceGiveFeedback
 */
export interface WorkspaceGiveFeedback {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceGiveFeedback
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface WorkspaceIdRequestBody
 */
export interface WorkspaceIdRequestBody {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceIdRequestBody
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface WorkspaceRead
 */
export interface WorkspaceRead {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRead
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRead
     */
    'customerId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRead
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceRead
     */
    'slug': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'initialSetupComplete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'displaySetupWizard'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'anonymousDataCollection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'news'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'securityUpdates'?: boolean;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof WorkspaceRead
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'firstCompletedSync'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRead
     */
    'feedbackDone'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkspaceReadList
 */
export interface WorkspaceReadList {
    /**
     * 
     * @type {Array<WorkspaceRead>}
     * @memberof WorkspaceReadList
     */
    'workspaces': Array<WorkspaceRead>;
}
/**
 * 
 * @export
 * @interface WorkspaceUpdate
 */
export interface WorkspaceUpdate {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUpdate
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUpdate
     */
    'initialSetupComplete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUpdate
     */
    'displaySetupWizard'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUpdate
     */
    'anonymousDataCollection': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUpdate
     */
    'news': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUpdate
     */
    'securityUpdates': boolean;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof WorkspaceUpdate
     */
    'notifications'?: Array<Notification>;
}
/**
 * 
 * @export
 * @interface WorkspaceUpdateName
 */
export interface WorkspaceUpdateName {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUpdateName
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUpdateName
     */
    'name': string;
}

/**
 * ConnectionApi - axios parameter creator
 * @export
 */
export const ConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a connection between a source and a destination
         * @param {ConnectionCreate} connectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (connectionCreate: ConnectionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionCreate' is not null or undefined
            assertParamExists('createConnection', 'connectionCreate', connectionCreate)
            const localVarPath = `/v1/connections/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('deleteConnection', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/connections/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('getConnection', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/connections/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch the current state for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getState: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('getState', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/state/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch the current type for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateType: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('getStateType', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/state/type/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connections for workspace, including deleted connections.
         * @summary Returns all connections for a workspace, including deleted connections.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllConnectionsForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('listAllConnectionsForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/connections/list_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connections for workspace. Does not return deleted connections.
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('listConnectionsForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/connections/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetConnection: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('resetConnection', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/connections/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search connections
         * @param {ConnectionSearch} connectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConnections: async (connectionSearch: ConnectionSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionSearch' is not null or undefined
            assertParamExists('searchConnections', 'connectionSearch', connectionSearch)
            const localVarPath = `/v1/connections/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a manual sync of the connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncConnection: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('syncConnection', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/connections/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a connection
         * @param {ConnectionUpdate} connectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection: async (connectionUpdate: ConnectionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionUpdate' is not null or undefined
            assertParamExists('updateConnection', 'connectionUpdate', connectionUpdate)
            const localVarPath = `/v1/connections/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionApi - functional programming interface
 * @export
 */
export const ConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a connection between a source and a destination
         * @param {ConnectionCreate} connectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(connectionCreate: ConnectionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(connectionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnection(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch the current state for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getState(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getState(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch the current type for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStateType(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionStateType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStateType(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List connections for workspace, including deleted connections.
         * @summary Returns all connections for a workspace, including deleted connections.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllConnectionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List connections for workspace. Does not return deleted connections.
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobInfoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetConnection(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search connections
         * @param {ConnectionSearch} connectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchConnections(connectionSearch: ConnectionSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchConnections(connectionSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a manual sync of the connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobInfoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncConnection(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a connection
         * @param {ConnectionUpdate} connectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnection(connectionUpdate: ConnectionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnection(connectionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectionApi - factory interface
 * @export
 */
export const ConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a connection between a source and a destination
         * @param {ConnectionCreate} connectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(connectionCreate: ConnectionCreate, options?: any): AxiosPromise<ConnectionRead> {
            return localVarFp.createConnection(connectionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConnection(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<ConnectionRead> {
            return localVarFp.getConnection(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch the current state for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getState(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<ConnectionState> {
            return localVarFp.getState(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch the current type for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateType(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<ConnectionStateType> {
            return localVarFp.getStateType(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections for workspace, including deleted connections.
         * @summary Returns all connections for a workspace, including deleted connections.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<ConnectionReadList> {
            return localVarFp.listAllConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * List connections for workspace. Does not return deleted connections.
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<ConnectionReadList> {
            return localVarFp.listConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<JobInfoRead> {
            return localVarFp.resetConnection(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search connections
         * @param {ConnectionSearch} connectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConnections(connectionSearch: ConnectionSearch, options?: any): AxiosPromise<ConnectionReadList> {
            return localVarFp.searchConnections(connectionSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a manual sync of the connection
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<JobInfoRead> {
            return localVarFp.syncConnection(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a connection
         * @param {ConnectionUpdate} connectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(connectionUpdate: ConnectionUpdate, options?: any): AxiosPromise<ConnectionRead> {
            return localVarFp.updateConnection(connectionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionApi - object-oriented interface
 * @export
 * @class ConnectionApi
 * @extends {BaseAPI}
 */
export class ConnectionApi extends BaseAPI {
    /**
     * 
     * @summary Create a connection between a source and a destination
     * @param {ConnectionCreate} connectionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public createConnection(connectionCreate: ConnectionCreate, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).createConnection(connectionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a connection
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public deleteConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).deleteConnection(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connection
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public getConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).getConnection(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch the current state for a connection.
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public getState(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).getState(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch the current type for a connection.
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public getStateType(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).getStateType(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connections for workspace, including deleted connections.
     * @summary Returns all connections for a workspace, including deleted connections.
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public listAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).listAllConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connections for workspace. Does not return deleted connections.
     * @summary Returns all connections for a workspace.
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public listConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).listConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public resetConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).resetConnection(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search connections
     * @param {ConnectionSearch} connectionSearch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public searchConnections(connectionSearch: ConnectionSearch, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).searchConnections(connectionSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a manual sync of the connection
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public syncConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).syncConnection(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a connection
     * @param {ConnectionUpdate} connectionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public updateConnection(connectionUpdate: ConnectionUpdate, options?: AxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).updateConnection(connectionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbMigrationApi - axios parameter creator
 * @export
 */
export const DbMigrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Migrate the database to the latest version
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMigrations: async (dbMigrationRequestBody: DbMigrationRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbMigrationRequestBody' is not null or undefined
            assertParamExists('executeMigrations', 'dbMigrationRequestBody', dbMigrationRequestBody)
            const localVarPath = `/v1/db_migrations/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbMigrationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all database migrations
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMigrations: async (dbMigrationRequestBody: DbMigrationRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbMigrationRequestBody' is not null or undefined
            assertParamExists('listMigrations', 'dbMigrationRequestBody', dbMigrationRequestBody)
            const localVarPath = `/v1/db_migrations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbMigrationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbMigrationApi - functional programming interface
 * @export
 */
export const DbMigrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DbMigrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Migrate the database to the latest version
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbMigrationExecutionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeMigrations(dbMigrationRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all database migrations
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbMigrationReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMigrations(dbMigrationRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DbMigrationApi - factory interface
 * @export
 */
export const DbMigrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DbMigrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Migrate the database to the latest version
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: any): AxiosPromise<DbMigrationExecutionRead> {
            return localVarFp.executeMigrations(dbMigrationRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all database migrations
         * @param {DbMigrationRequestBody} dbMigrationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: any): AxiosPromise<DbMigrationReadList> {
            return localVarFp.listMigrations(dbMigrationRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DbMigrationApi - object-oriented interface
 * @export
 * @class DbMigrationApi
 * @extends {BaseAPI}
 */
export class DbMigrationApi extends BaseAPI {
    /**
     * 
     * @summary Migrate the database to the latest version
     * @param {DbMigrationRequestBody} dbMigrationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbMigrationApi
     */
    public executeMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: AxiosRequestConfig) {
        return DbMigrationApiFp(this.configuration).executeMigrations(dbMigrationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all database migrations
     * @param {DbMigrationRequestBody} dbMigrationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbMigrationApi
     */
    public listMigrations(dbMigrationRequestBody: DbMigrationRequestBody, options?: AxiosRequestConfig) {
        return DbMigrationApiFp(this.configuration).listMigrations(dbMigrationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export Airbyte Configuration and Data Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportArchive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/deployment/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Airbyte Workspace Configuration
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('exportWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/deployment/export_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Airbyte Configuration and Data Archive
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importArchive: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('importArchive', 'body', body)
            const localVarPath = `/v1/deployment/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/x-gzip';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with \'deployment/upload_archive_resource\' first 
         * @param {ImportRequestBody} importRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoWorkspace: async (importRequestBody: ImportRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importRequestBody' is not null or undefined
            assertParamExists('importIntoWorkspace', 'importRequestBody', importRequestBody)
            const localVarPath = `/v1/deployment/import_into_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a GZIP archive tarball and stage it in the server\'s cache as a temporary resource
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArchiveResource: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadArchiveResource', 'body', body)
            const localVarPath = `/v1/deployment/upload_archive_resource`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/x-gzip';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export Airbyte Configuration and Data Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportArchive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportArchive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export Airbyte Workspace Configuration
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import Airbyte Configuration and Data Archive
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importArchive(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importArchive(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with \'deployment/upload_archive_resource\' first 
         * @param {ImportRequestBody} importRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importIntoWorkspace(importRequestBody: ImportRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIntoWorkspace(importRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a GZIP archive tarball and stage it in the server\'s cache as a temporary resource
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadArchiveResource(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadArchiveResource(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Export Airbyte Configuration and Data Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportArchive(options?: any): AxiosPromise<any> {
            return localVarFp.exportArchive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export Airbyte Workspace Configuration
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<any> {
            return localVarFp.exportWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Airbyte Configuration and Data Archive
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importArchive(body: any, options?: any): AxiosPromise<ImportRead> {
            return localVarFp.importArchive(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with \'deployment/upload_archive_resource\' first 
         * @param {ImportRequestBody} importRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoWorkspace(importRequestBody: ImportRequestBody, options?: any): AxiosPromise<ImportRead> {
            return localVarFp.importIntoWorkspace(importRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a GZIP archive tarball and stage it in the server\'s cache as a temporary resource
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArchiveResource(body: any, options?: any): AxiosPromise<UploadRead> {
            return localVarFp.uploadArchiveResource(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Export Airbyte Configuration and Data Archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public exportArchive(options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).exportArchive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export Airbyte Workspace Configuration
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public exportWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).exportWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Airbyte Configuration and Data Archive
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public importArchive(body: any, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).importArchive(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with \'deployment/upload_archive_resource\' first 
     * @param {ImportRequestBody} importRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public importIntoWorkspace(importRequestBody: ImportRequestBody, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).importIntoWorkspace(importRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a GZIP archive tarball and stage it in the server\'s cache as a temporary resource
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public uploadArchiveResource(body: any, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).uploadArchiveResource(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DestinationApi - axios parameter creator
 * @export
 */
export const DestinationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check connection to the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToDestination: async (destinationIdRequestBody: DestinationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationIdRequestBody' is not null or undefined
            assertParamExists('checkConnectionToDestination', 'destinationIdRequestBody', destinationIdRequestBody)
            const localVarPath = `/v1/destinations/check_connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check connection for a proposed update to a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToDestinationForUpdate: async (destinationUpdate: DestinationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationUpdate' is not null or undefined
            assertParamExists('checkConnectionToDestinationForUpdate', 'destinationUpdate', destinationUpdate)
            const localVarPath = `/v1/destinations/check_connection_for_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDestination: async (destinationIdRequestBody: DestinationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationIdRequestBody' is not null or undefined
            assertParamExists('cloneDestination', 'destinationIdRequestBody', destinationIdRequestBody)
            const localVarPath = `/v1/destinations/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a destination
         * @param {DestinationCreate} destinationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestination: async (destinationCreate: DestinationCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationCreate' is not null or undefined
            assertParamExists('createDestination', 'destinationCreate', destinationCreate)
            const localVarPath = `/v1/destinations/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination: async (destinationIdRequestBody: DestinationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationIdRequestBody' is not null or undefined
            assertParamExists('deleteDestination', 'destinationIdRequestBody', destinationIdRequestBody)
            const localVarPath = `/v1/destinations/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configured destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination: async (destinationIdRequestBody: DestinationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationIdRequestBody' is not null or undefined
            assertParamExists('getDestination', 'destinationIdRequestBody', destinationIdRequestBody)
            const localVarPath = `/v1/destinations/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List configured destinations for a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationsForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('listDestinationsForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/destinations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search destinations
         * @param {DestinationSearch} destinationSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDestinations: async (destinationSearch: DestinationSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationSearch' is not null or undefined
            assertParamExists('searchDestinations', 'destinationSearch', destinationSearch)
            const localVarPath = `/v1/destinations/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDestination: async (destinationUpdate: DestinationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationUpdate' is not null or undefined
            assertParamExists('updateDestination', 'destinationUpdate', destinationUpdate)
            const localVarPath = `/v1/destinations/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DestinationApi - functional programming interface
 * @export
 */
export const DestinationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DestinationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check connection to the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionToDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionToDestination(destinationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check connection for a proposed update to a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionToDestinationForUpdate(destinationUpdate: DestinationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionToDestinationForUpdate(destinationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clone destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDestination(destinationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a destination
         * @param {DestinationCreate} destinationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDestination(destinationCreate: DestinationCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDestination(destinationCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDestination(destinationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get configured destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestination(destinationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List configured destinations for a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDestinationsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDestinationsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search destinations
         * @param {DestinationSearch} destinationSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDestinations(destinationSearch: DestinationSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDestinations(destinationSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDestination(destinationUpdate: DestinationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDestination(destinationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DestinationApi - factory interface
 * @export
 */
export const DestinationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DestinationApiFp(configuration)
    return {
        /**
         * 
         * @summary Check connection to the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.checkConnectionToDestination(destinationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check connection for a proposed update to a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToDestinationForUpdate(destinationUpdate: DestinationUpdate, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.checkConnectionToDestinationForUpdate(destinationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clone destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: any): AxiosPromise<DestinationRead> {
            return localVarFp.cloneDestination(destinationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a destination
         * @param {DestinationCreate} destinationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestination(destinationCreate: DestinationCreate, options?: any): AxiosPromise<DestinationRead> {
            return localVarFp.createDestination(destinationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDestination(destinationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get configured destination
         * @param {DestinationIdRequestBody} destinationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: any): AxiosPromise<DestinationRead> {
            return localVarFp.getDestination(destinationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List configured destinations for a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<DestinationReadList> {
            return localVarFp.listDestinationsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search destinations
         * @param {DestinationSearch} destinationSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDestinations(destinationSearch: DestinationSearch, options?: any): AxiosPromise<DestinationReadList> {
            return localVarFp.searchDestinations(destinationSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a destination
         * @param {DestinationUpdate} destinationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDestination(destinationUpdate: DestinationUpdate, options?: any): AxiosPromise<DestinationRead> {
            return localVarFp.updateDestination(destinationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DestinationApi - object-oriented interface
 * @export
 * @class DestinationApi
 * @extends {BaseAPI}
 */
export class DestinationApi extends BaseAPI {
    /**
     * 
     * @summary Check connection to the destination
     * @param {DestinationIdRequestBody} destinationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public checkConnectionToDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).checkConnectionToDestination(destinationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check connection for a proposed update to a destination
     * @param {DestinationUpdate} destinationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public checkConnectionToDestinationForUpdate(destinationUpdate: DestinationUpdate, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).checkConnectionToDestinationForUpdate(destinationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clone destination
     * @param {DestinationIdRequestBody} destinationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public cloneDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).cloneDestination(destinationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a destination
     * @param {DestinationCreate} destinationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public createDestination(destinationCreate: DestinationCreate, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).createDestination(destinationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the destination
     * @param {DestinationIdRequestBody} destinationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public deleteDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).deleteDestination(destinationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get configured destination
     * @param {DestinationIdRequestBody} destinationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public getDestination(destinationIdRequestBody: DestinationIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).getDestination(destinationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List configured destinations for a workspace
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public listDestinationsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).listDestinationsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search destinations
     * @param {DestinationSearch} destinationSearch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public searchDestinations(destinationSearch: DestinationSearch, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).searchDestinations(destinationSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a destination
     * @param {DestinationUpdate} destinationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationApi
     */
    public updateDestination(destinationUpdate: DestinationUpdate, options?: AxiosRequestConfig) {
        return DestinationApiFp(this.configuration).updateDestination(destinationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DestinationDefinitionApi - axios parameter creator
 * @export
 */
export const DestinationDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionCreate} [customDestinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomDestinationDefinition: async (customDestinationDefinitionCreate?: CustomDestinationDefinitionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/create_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDestinationDefinitionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a destinationsDefinition
         * @param {DestinationDefinitionCreate} [destinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestinationDefinition: async (destinationDefinitionCreate?: DestinationDefinitionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom destination definition for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDestinationDefinition: async (destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('deleteCustomDestinationDefinition', 'destinationDefinitionIdWithWorkspaceId', destinationDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/destination_definitions/delete_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a destination definition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestinationDefinition: async (destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdRequestBody' is not null or undefined
            assertParamExists('deleteDestinationDefinition', 'destinationDefinitionIdRequestBody', destinationDefinitionIdRequestBody)
            const localVarPath = `/v1/destination_definitions/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get destinationDefinition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinition: async (destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdRequestBody' is not null or undefined
            assertParamExists('getDestinationDefinition', 'destinationDefinitionIdRequestBody', destinationDefinitionIdRequestBody)
            const localVarPath = `/v1/destination_definitions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a destinationDefinition that is configured for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinitionForWorkspace: async (destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('getDestinationDefinitionForWorkspace', 'destinationDefinitionIdWithWorkspaceId', destinationDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/destination_definitions/get_for_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary grant a private, non-custom destinationDefinition to a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantDestinationDefinitionToWorkspace: async (destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('grantDestinationDefinitionToWorkspace', 'destinationDefinitionIdWithWorkspaceId', destinationDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/destination_definitions/grant_definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the destinationDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationDefinitionsForWorkspace: async (workspaceIdRequestBody?: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/list_for_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Guaranteed to retrieve the latest information on supported destinations.
         * @summary List the latest destinationDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLatestDestinationDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/list_latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateDestinationDefinitions: async (workspaceIdRequestBody?: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/list_private`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeDestinationDefinitionFromWorkspace: async (destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('revokeDestinationDefinitionFromWorkspace', 'destinationDefinitionIdWithWorkspaceId', destinationDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/destination_definitions/revoke_definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionUpdate} [customDestinationDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomDestinationDefinition: async (customDestinationDefinitionUpdate?: CustomDestinationDefinitionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/destination_definitions/update_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDestinationDefinitionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update destinationDefinition
         * @param {DestinationDefinitionUpdate} destinationDefinitionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDestinationDefinition: async (destinationDefinitionUpdate: DestinationDefinitionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionUpdate' is not null or undefined
            assertParamExists('updateDestinationDefinition', 'destinationDefinitionUpdate', destinationDefinitionUpdate)
            const localVarPath = `/v1/destination_definitions/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DestinationDefinitionApi - functional programming interface
 * @export
 */
export const DestinationDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DestinationDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionCreate} [customDestinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomDestinationDefinition(customDestinationDefinitionCreate?: CustomDestinationDefinitionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomDestinationDefinition(customDestinationDefinitionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a destinationsDefinition
         * @param {DestinationDefinitionCreate} [destinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDestinationDefinition(destinationDefinitionCreate?: DestinationDefinitionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDestinationDefinition(destinationDefinitionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a custom destination definition for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a destination definition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDestinationDefinition(destinationDefinitionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get destinationDefinition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinationDefinition(destinationDefinitionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a destinationDefinition that is configured for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary grant a private, non-custom destinationDefinition to a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateDestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDestinationDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDestinationDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the destinationDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDestinationDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDestinationDefinitionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Guaranteed to retrieve the latest information on supported destinations.
         * @summary List the latest destinationDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLatestDestinationDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLatestDestinationDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrivateDestinationDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateDestinationDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrivateDestinationDefinitions(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionUpdate} [customDestinationDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomDestinationDefinition(customDestinationDefinitionUpdate?: CustomDestinationDefinitionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomDestinationDefinition(customDestinationDefinitionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update destinationDefinition
         * @param {DestinationDefinitionUpdate} destinationDefinitionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDestinationDefinition(destinationDefinitionUpdate: DestinationDefinitionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDestinationDefinition(destinationDefinitionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DestinationDefinitionApi - factory interface
 * @export
 */
export const DestinationDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DestinationDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionCreate} [customDestinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomDestinationDefinition(customDestinationDefinitionCreate?: CustomDestinationDefinitionCreate, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.createCustomDestinationDefinition(customDestinationDefinitionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a destinationsDefinition
         * @param {DestinationDefinitionCreate} [destinationDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestinationDefinition(destinationDefinitionCreate?: DestinationDefinitionCreate, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.createDestinationDefinition(destinationDefinitionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom destination definition for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a destination definition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDestinationDefinition(destinationDefinitionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get destinationDefinition
         * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.getDestinationDefinition(destinationDefinitionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a destinationDefinition that is configured for the given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary grant a private, non-custom destinationDefinition to a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<PrivateDestinationDefinitionRead> {
            return localVarFp.grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationDefinitions(options?: any): AxiosPromise<DestinationDefinitionReadList> {
            return localVarFp.listDestinationDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the destinationDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinationDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: any): AxiosPromise<DestinationDefinitionReadList> {
            return localVarFp.listDestinationDefinitionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Guaranteed to retrieve the latest information on supported destinations.
         * @summary List the latest destinationDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLatestDestinationDefinitions(options?: any): AxiosPromise<DestinationDefinitionReadList> {
            return localVarFp.listLatestDestinationDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateDestinationDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: any): AxiosPromise<PrivateDestinationDefinitionReadList> {
            return localVarFp.listPrivateDestinationDefinitions(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<void> {
            return localVarFp.revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a custom destinationDefinition for the given workspace
         * @param {CustomDestinationDefinitionUpdate} [customDestinationDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomDestinationDefinition(customDestinationDefinitionUpdate?: CustomDestinationDefinitionUpdate, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.updateCustomDestinationDefinition(customDestinationDefinitionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update destinationDefinition
         * @param {DestinationDefinitionUpdate} destinationDefinitionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDestinationDefinition(destinationDefinitionUpdate: DestinationDefinitionUpdate, options?: any): AxiosPromise<DestinationDefinitionRead> {
            return localVarFp.updateDestinationDefinition(destinationDefinitionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DestinationDefinitionApi - object-oriented interface
 * @export
 * @class DestinationDefinitionApi
 * @extends {BaseAPI}
 */
export class DestinationDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Creates a custom destinationDefinition for the given workspace
     * @param {CustomDestinationDefinitionCreate} [customDestinationDefinitionCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public createCustomDestinationDefinition(customDestinationDefinitionCreate?: CustomDestinationDefinitionCreate, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).createCustomDestinationDefinition(customDestinationDefinitionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a destinationsDefinition
     * @param {DestinationDefinitionCreate} [destinationDefinitionCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public createDestinationDefinition(destinationDefinitionCreate?: DestinationDefinitionCreate, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).createDestinationDefinition(destinationDefinitionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom destination definition for the given workspace
     * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).deleteCustomDestinationDefinition(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a destination definition
     * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public deleteDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).deleteDestinationDefinition(destinationDefinitionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get destinationDefinition
     * @param {DestinationDefinitionIdRequestBody} destinationDefinitionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public getDestinationDefinition(destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).getDestinationDefinition(destinationDefinitionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a destinationDefinition that is configured for the given workspace
     * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).getDestinationDefinitionForWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary grant a private, non-custom destinationDefinition to a given workspace
     * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).grantDestinationDefinitionToWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public listDestinationDefinitions(options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).listDestinationDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the destinationDefinitions the given workspace is configured to use
     * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public listDestinationDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).listDestinationDefinitionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Guaranteed to retrieve the latest information on supported destinations.
     * @summary List the latest destinationDefinitions Airbyte supports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public listLatestDestinationDefinitions(options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).listLatestDestinationDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
     * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public listPrivateDestinationDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).listPrivateDestinationDefinitions(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
     * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).revokeDestinationDefinitionFromWorkspace(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a custom destinationDefinition for the given workspace
     * @param {CustomDestinationDefinitionUpdate} [customDestinationDefinitionUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public updateCustomDestinationDefinition(customDestinationDefinitionUpdate?: CustomDestinationDefinitionUpdate, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).updateCustomDestinationDefinition(customDestinationDefinitionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update destinationDefinition
     * @param {DestinationDefinitionUpdate} destinationDefinitionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionApi
     */
    public updateDestinationDefinition(destinationDefinitionUpdate: DestinationDefinitionUpdate, options?: AxiosRequestConfig) {
        return DestinationDefinitionApiFp(this.configuration).updateDestinationDefinition(destinationDefinitionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DestinationDefinitionSpecificationApi - axios parameter creator
 * @export
 */
export const DestinationDefinitionSpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get specification for a destinationDefinition
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinitionSpecification: async (destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('getDestinationDefinitionSpecification', 'destinationDefinitionIdWithWorkspaceId', destinationDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/destination_definition_specifications/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DestinationDefinitionSpecificationApi - functional programming interface
 * @export
 */
export const DestinationDefinitionSpecificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DestinationDefinitionSpecificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get specification for a destinationDefinition
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationDefinitionSpecificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DestinationDefinitionSpecificationApi - factory interface
 * @export
 */
export const DestinationDefinitionSpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DestinationDefinitionSpecificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get specification for a destinationDefinition
         * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<DestinationDefinitionSpecificationRead> {
            return localVarFp.getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DestinationDefinitionSpecificationApi - object-oriented interface
 * @export
 * @class DestinationDefinitionSpecificationApi
 * @extends {BaseAPI}
 */
export class DestinationDefinitionSpecificationApi extends BaseAPI {
    /**
     * 
     * @summary Get specification for a destinationDefinition
     * @param {DestinationDefinitionIdWithWorkspaceId} destinationDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestinationDefinitionSpecificationApi
     */
    public getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return DestinationDefinitionSpecificationApiFp(this.configuration).getDestinationDefinitionSpecification(destinationDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: any): AxiosPromise<HealthCheckRead> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealthCheck(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob: async (jobIdRequestBody: JobIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobIdRequestBody' is not null or undefined
            assertParamExists('cancelJob', 'jobIdRequestBody', jobIdRequestBody)
            const localVarPath = `/v1/jobs/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all information needed to debug this job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDebugInfo: async (jobIdRequestBody: JobIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobIdRequestBody' is not null or undefined
            assertParamExists('getJobDebugInfo', 'jobIdRequestBody', jobIdRequestBody)
            const localVarPath = `/v1/jobs/get_debug_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInfo: async (jobIdRequestBody: JobIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobIdRequestBody' is not null or undefined
            assertParamExists('getJobInfo', 'jobIdRequestBody', jobIdRequestBody)
            const localVarPath = `/v1/jobs/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
         * @param {JobListRequestBody} jobListRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobsFor: async (jobListRequestBody: JobListRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobListRequestBody' is not null or undefined
            assertParamExists('listJobsFor', 'jobListRequestBody', jobListRequestBody)
            const localVarPath = `/v1/jobs/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobListRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJob(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobInfoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJob(jobIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all information needed to debug this job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobDebugInfo(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDebugInfoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobDebugInfo(jobIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobInfo(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobInfoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobInfo(jobIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
         * @param {JobListRequestBody} jobListRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobsFor(jobListRequestBody: JobListRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobsFor(jobListRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob(jobIdRequestBody: JobIdRequestBody, options?: any): AxiosPromise<JobInfoRead> {
            return localVarFp.cancelJob(jobIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all information needed to debug this job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDebugInfo(jobIdRequestBody: JobIdRequestBody, options?: any): AxiosPromise<JobDebugInfoRead> {
            return localVarFp.getJobDebugInfo(jobIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a job
         * @param {JobIdRequestBody} jobIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInfo(jobIdRequestBody: JobIdRequestBody, options?: any): AxiosPromise<JobInfoRead> {
            return localVarFp.getJobInfo(jobIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
         * @param {JobListRequestBody} jobListRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobsFor(jobListRequestBody: JobListRequestBody, options?: any): AxiosPromise<JobReadList> {
            return localVarFp.listJobsFor(jobListRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a job
     * @param {JobIdRequestBody} jobIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public cancelJob(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).cancelJob(jobIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all information needed to debug this job
     * @param {JobIdRequestBody} jobIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobDebugInfo(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobDebugInfo(jobIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a job
     * @param {JobIdRequestBody} jobIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobInfo(jobIdRequestBody: JobIdRequestBody, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobInfo(jobIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
     * @param {JobListRequestBody} jobListRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobsFor(jobListRequestBody: JobListRequestBody, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobsFor(jobListRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get logs
         * @param {LogsRequestBody} logsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs: async (logsRequestBody: LogsRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logsRequestBody' is not null or undefined
            assertParamExists('getLogs', 'logsRequestBody', logsRequestBody)
            const localVarPath = `/v1/logs/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get logs
         * @param {LogsRequestBody} logsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogs(logsRequestBody: LogsRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogs(logsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get logs
         * @param {LogsRequestBody} logsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(logsRequestBody: LogsRequestBody, options?: any): AxiosPromise<any> {
            return localVarFp.getLogs(logsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get logs
     * @param {LogsRequestBody} logsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getLogs(logsRequestBody: LogsRequestBody, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).getLogs(logsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Try sending a notifications
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryNotificationConfig: async (notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('tryNotificationConfig', 'notification', notification)
            const localVarPath = `/v1/notifications/try`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Try sending a notifications
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryNotificationConfig(notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tryNotificationConfig(notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Try sending a notifications
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryNotificationConfig(notification: Notification, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.tryNotificationConfig(notification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Try sending a notifications
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public tryNotificationConfig(notification: Notification, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).tryNotificationConfig(notification, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OauthApi - axios parameter creator
 * @export
 */
export const OauthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Given a destination def ID generate an access/refresh token etc.
         * @param {CompleteDestinationOAuthRequest} completeDestinationOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeDestinationOAuth: async (completeDestinationOAuthRequest: CompleteDestinationOAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeDestinationOAuthRequest' is not null or undefined
            assertParamExists('completeDestinationOAuth', 'completeDestinationOAuthRequest', completeDestinationOAuthRequest)
            const localVarPath = `/v1/destination_oauths/complete_oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeDestinationOAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Given a source def ID generate an access/refresh token etc.
         * @param {CompleteSourceOauthRequest} completeSourceOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSourceOAuth: async (completeSourceOauthRequest: CompleteSourceOauthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSourceOauthRequest' is not null or undefined
            assertParamExists('completeSourceOAuth', 'completeSourceOauthRequest', completeSourceOauthRequest)
            const localVarPath = `/v1/source_oauths/complete_oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSourceOauthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {DestinationOauthConsentRequest} destinationOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationOAuthConsent: async (destinationOauthConsentRequest: DestinationOauthConsentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationOauthConsentRequest' is not null or undefined
            assertParamExists('getDestinationOAuthConsent', 'destinationOauthConsentRequest', destinationOauthConsentRequest)
            const localVarPath = `/v1/destination_oauths/get_consent_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationOauthConsentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {SourceOauthConsentRequest} sourceOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceOAuthConsent: async (sourceOauthConsentRequest: SourceOauthConsentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceOauthConsentRequest' is not null or undefined
            assertParamExists('getSourceOAuthConsent', 'sourceOauthConsentRequest', sourceOauthConsentRequest)
            const localVarPath = `/v1/source_oauths/get_consent_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceOauthConsentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideDestinationOauthParamsRequestBody} setInstancewideDestinationOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstancewideDestinationOauthParams: async (setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setInstancewideDestinationOauthParamsRequestBody' is not null or undefined
            assertParamExists('setInstancewideDestinationOauthParams', 'setInstancewideDestinationOauthParamsRequestBody', setInstancewideDestinationOauthParamsRequestBody)
            const localVarPath = `/v1/destination_oauths/oauth_params/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setInstancewideDestinationOauthParamsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideSourceOauthParamsRequestBody} setInstancewideSourceOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstancewideSourceOauthParams: async (setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setInstancewideSourceOauthParamsRequestBody' is not null or undefined
            assertParamExists('setInstancewideSourceOauthParams', 'setInstancewideSourceOauthParamsRequestBody', setInstancewideSourceOauthParamsRequestBody)
            const localVarPath = `/v1/source_oauths/oauth_params/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setInstancewideSourceOauthParamsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OauthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Given a destination def ID generate an access/refresh token etc.
         * @param {CompleteDestinationOAuthRequest} completeDestinationOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeDestinationOAuth(completeDestinationOAuthRequest: CompleteDestinationOAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeDestinationOAuth(completeDestinationOAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Given a source def ID generate an access/refresh token etc.
         * @param {CompleteSourceOauthRequest} completeSourceOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeSourceOAuth(completeSourceOauthRequest: CompleteSourceOauthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeSourceOAuth(completeSourceOauthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {DestinationOauthConsentRequest} destinationOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinationOAuthConsent(destinationOauthConsentRequest: DestinationOauthConsentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConsentRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinationOAuthConsent(destinationOauthConsentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {SourceOauthConsentRequest} sourceOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceOAuthConsent(sourceOauthConsentRequest: SourceOauthConsentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConsentRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceOAuthConsent(sourceOauthConsentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideDestinationOauthParamsRequestBody} setInstancewideDestinationOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideSourceOauthParamsRequestBody} setInstancewideSourceOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OauthApiFp(configuration)
    return {
        /**
         * 
         * @summary Given a destination def ID generate an access/refresh token etc.
         * @param {CompleteDestinationOAuthRequest} completeDestinationOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeDestinationOAuth(completeDestinationOAuthRequest: CompleteDestinationOAuthRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.completeDestinationOAuth(completeDestinationOAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Given a source def ID generate an access/refresh token etc.
         * @param {CompleteSourceOauthRequest} completeSourceOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSourceOAuth(completeSourceOauthRequest: CompleteSourceOauthRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.completeSourceOAuth(completeSourceOauthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {DestinationOauthConsentRequest} destinationOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinationOAuthConsent(destinationOauthConsentRequest: DestinationOauthConsentRequest, options?: any): AxiosPromise<OAuthConsentRead> {
            return localVarFp.getDestinationOAuthConsent(destinationOauthConsentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
         * @param {SourceOauthConsentRequest} sourceOauthConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceOAuthConsent(sourceOauthConsentRequest: SourceOauthConsentRequest, options?: any): AxiosPromise<OAuthConsentRead> {
            return localVarFp.getSourceOAuthConsent(sourceOauthConsentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideDestinationOauthParamsRequestBody} setInstancewideDestinationOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
         * @param {SetInstancewideSourceOauthParamsRequestBody} setInstancewideSourceOauthParamsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
    /**
     * 
     * @summary Given a destination def ID generate an access/refresh token etc.
     * @param {CompleteDestinationOAuthRequest} completeDestinationOAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public completeDestinationOAuth(completeDestinationOAuthRequest: CompleteDestinationOAuthRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).completeDestinationOAuth(completeDestinationOAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Given a source def ID generate an access/refresh token etc.
     * @param {CompleteSourceOauthRequest} completeSourceOauthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public completeSourceOAuth(completeSourceOauthRequest: CompleteSourceOauthRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).completeSourceOAuth(completeSourceOauthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
     * @param {DestinationOauthConsentRequest} destinationOauthConsentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public getDestinationOAuthConsent(destinationOauthConsentRequest: DestinationOauthConsentRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).getDestinationOAuthConsent(destinationOauthConsentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
     * @param {SourceOauthConsentRequest} sourceOauthConsentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public getSourceOAuthConsent(sourceOauthConsentRequest: SourceOauthConsentRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).getSourceOAuthConsent(sourceOauthConsentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
     * @param {SetInstancewideDestinationOauthParamsRequestBody} setInstancewideDestinationOauthParamsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).setInstancewideDestinationOauthParams(setInstancewideDestinationOauthParamsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector\'s configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company\'s Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. 
     * @param {SetInstancewideSourceOauthParamsRequestBody} setInstancewideSourceOauthParamsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).setInstancewideSourceOauthParams(setInstancewideSourceOauthParamsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenapiApi - axios parameter creator
 * @export
 */
export const OpenapiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the openapi specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/openapi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenapiApi - functional programming interface
 * @export
 */
export const OpenapiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenapiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the openapi specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenApiSpec(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenApiSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenapiApi - factory interface
 * @export
 */
export const OpenapiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenapiApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the openapi specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec(options?: any): AxiosPromise<any> {
            return localVarFp.getOpenApiSpec(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenapiApi - object-oriented interface
 * @export
 * @class OpenapiApi
 * @extends {BaseAPI}
 */
export class OpenapiApi extends BaseAPI {
    /**
     * 
     * @summary Returns the openapi specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenapiApi
     */
    public getOpenApiSpec(options?: AxiosRequestConfig) {
        return OpenapiApiFp(this.configuration).getOpenApiSpec(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OperationApi - axios parameter creator
 * @export
 */
export const OperationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if an operation to be created is valid
         * @param {OperatorConfiguration} operatorConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOperation: async (operatorConfiguration: OperatorConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorConfiguration' is not null or undefined
            assertParamExists('checkOperation', 'operatorConfiguration', operatorConfiguration)
            const localVarPath = `/v1/operations/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operatorConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an operation to be applied as part of a connection pipeline
         * @param {OperationCreate} operationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperation: async (operationCreate: OperationCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationCreate' is not null or undefined
            assertParamExists('createOperation', 'operationCreate', operationCreate)
            const localVarPath = `/v1/operations/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation: async (operationIdRequestBody: OperationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationIdRequestBody' is not null or undefined
            assertParamExists('deleteOperation', 'operationIdRequestBody', operationIdRequestBody)
            const localVarPath = `/v1/operations/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation: async (operationIdRequestBody: OperationIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationIdRequestBody' is not null or undefined
            assertParamExists('getOperation', 'operationIdRequestBody', operationIdRequestBody)
            const localVarPath = `/v1/operations/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List operations for connection.
         * @summary Returns all operations for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperationsForConnection: async (connectionIdRequestBody: ConnectionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionIdRequestBody' is not null or undefined
            assertParamExists('listOperationsForConnection', 'connectionIdRequestBody', connectionIdRequestBody)
            const localVarPath = `/v1/operations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an operation
         * @param {OperationUpdate} operationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation: async (operationUpdate: OperationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationUpdate' is not null or undefined
            assertParamExists('updateOperation', 'operationUpdate', operationUpdate)
            const localVarPath = `/v1/operations/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationApi - functional programming interface
 * @export
 */
export const OperationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check if an operation to be created is valid
         * @param {OperatorConfiguration} operatorConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkOperation(operatorConfiguration: OperatorConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckOperationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkOperation(operatorConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an operation to be applied as part of a connection pipeline
         * @param {OperationCreate} operationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOperation(operationCreate: OperationCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOperation(operationCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperation(operationIdRequestBody: OperationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperation(operationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperation(operationIdRequestBody: OperationIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperation(operationIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List operations for connection.
         * @summary Returns all operations for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOperationsForConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOperationsForConnection(connectionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an operation
         * @param {OperationUpdate} operationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperation(operationUpdate: OperationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperation(operationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OperationApi - factory interface
 * @export
 */
export const OperationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationApiFp(configuration)
    return {
        /**
         * 
         * @summary Check if an operation to be created is valid
         * @param {OperatorConfiguration} operatorConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOperation(operatorConfiguration: OperatorConfiguration, options?: any): AxiosPromise<CheckOperationRead> {
            return localVarFp.checkOperation(operatorConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an operation to be applied as part of a connection pipeline
         * @param {OperationCreate} operationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperation(operationCreate: OperationCreate, options?: any): AxiosPromise<OperationRead> {
            return localVarFp.createOperation(operationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation(operationIdRequestBody: OperationIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOperation(operationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an operation
         * @param {OperationIdRequestBody} operationIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation(operationIdRequestBody: OperationIdRequestBody, options?: any): AxiosPromise<OperationRead> {
            return localVarFp.getOperation(operationIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * List operations for connection.
         * @summary Returns all operations for a connection.
         * @param {ConnectionIdRequestBody} connectionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperationsForConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: any): AxiosPromise<OperationReadList> {
            return localVarFp.listOperationsForConnection(connectionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an operation
         * @param {OperationUpdate} operationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation(operationUpdate: OperationUpdate, options?: any): AxiosPromise<OperationRead> {
            return localVarFp.updateOperation(operationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationApi - object-oriented interface
 * @export
 * @class OperationApi
 * @extends {BaseAPI}
 */
export class OperationApi extends BaseAPI {
    /**
     * 
     * @summary Check if an operation to be created is valid
     * @param {OperatorConfiguration} operatorConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public checkOperation(operatorConfiguration: OperatorConfiguration, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).checkOperation(operatorConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an operation to be applied as part of a connection pipeline
     * @param {OperationCreate} operationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public createOperation(operationCreate: OperationCreate, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).createOperation(operationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an operation
     * @param {OperationIdRequestBody} operationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public deleteOperation(operationIdRequestBody: OperationIdRequestBody, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).deleteOperation(operationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an operation
     * @param {OperationIdRequestBody} operationIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public getOperation(operationIdRequestBody: OperationIdRequestBody, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).getOperation(operationIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List operations for connection.
     * @summary Returns all operations for a connection.
     * @param {ConnectionIdRequestBody} connectionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public listOperationsForConnection(connectionIdRequestBody: ConnectionIdRequestBody, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).listOperationsForConnection(connectionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an operation
     * @param {OperationUpdate} operationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public updateOperation(operationUpdate: OperationUpdate, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).updateOperation(operationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchedulerApi - axios parameter creator
 * @export
 */
export const SchedulerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Run check connection for a given destination configuration
         * @param {DestinationCoreConfig} destinationCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeDestinationCheckConnection: async (destinationCoreConfig: DestinationCoreConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationCoreConfig' is not null or undefined
            assertParamExists('executeDestinationCheckConnection', 'destinationCoreConfig', destinationCoreConfig)
            const localVarPath = `/v1/scheduler/destinations/check_connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationCoreConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run check connection for a given source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSourceCheckConnection: async (sourceCoreConfig: SourceCoreConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceCoreConfig' is not null or undefined
            assertParamExists('executeSourceCheckConnection', 'sourceCoreConfig', sourceCoreConfig)
            const localVarPath = `/v1/scheduler/sources/check_connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCoreConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run discover schema for a given source a source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSourceDiscoverSchema: async (sourceCoreConfig: SourceCoreConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceCoreConfig' is not null or undefined
            assertParamExists('executeSourceDiscoverSchema', 'sourceCoreConfig', sourceCoreConfig)
            const localVarPath = `/v1/scheduler/sources/discover_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCoreConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulerApi - functional programming interface
 * @export
 */
export const SchedulerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Run check connection for a given destination configuration
         * @param {DestinationCoreConfig} destinationCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeDestinationCheckConnection(destinationCoreConfig: DestinationCoreConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeDestinationCheckConnection(destinationCoreConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run check connection for a given source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSourceCheckConnection(sourceCoreConfig: SourceCoreConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSourceCheckConnection(sourceCoreConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run discover schema for a given source a source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSourceDiscoverSchema(sourceCoreConfig: SourceCoreConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDiscoverSchemaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSourceDiscoverSchema(sourceCoreConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchedulerApi - factory interface
 * @export
 */
export const SchedulerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulerApiFp(configuration)
    return {
        /**
         * 
         * @summary Run check connection for a given destination configuration
         * @param {DestinationCoreConfig} destinationCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeDestinationCheckConnection(destinationCoreConfig: DestinationCoreConfig, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.executeDestinationCheckConnection(destinationCoreConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run check connection for a given source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSourceCheckConnection(sourceCoreConfig: SourceCoreConfig, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.executeSourceCheckConnection(sourceCoreConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run discover schema for a given source a source configuration
         * @param {SourceCoreConfig} sourceCoreConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSourceDiscoverSchema(sourceCoreConfig: SourceCoreConfig, options?: any): AxiosPromise<SourceDiscoverSchemaRead> {
            return localVarFp.executeSourceDiscoverSchema(sourceCoreConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulerApi - object-oriented interface
 * @export
 * @class SchedulerApi
 * @extends {BaseAPI}
 */
export class SchedulerApi extends BaseAPI {
    /**
     * 
     * @summary Run check connection for a given destination configuration
     * @param {DestinationCoreConfig} destinationCoreConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerApi
     */
    public executeDestinationCheckConnection(destinationCoreConfig: DestinationCoreConfig, options?: AxiosRequestConfig) {
        return SchedulerApiFp(this.configuration).executeDestinationCheckConnection(destinationCoreConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run check connection for a given source configuration
     * @param {SourceCoreConfig} sourceCoreConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerApi
     */
    public executeSourceCheckConnection(sourceCoreConfig: SourceCoreConfig, options?: AxiosRequestConfig) {
        return SchedulerApiFp(this.configuration).executeSourceCheckConnection(sourceCoreConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run discover schema for a given source a source configuration
     * @param {SourceCoreConfig} sourceCoreConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerApi
     */
    public executeSourceDiscoverSchema(sourceCoreConfig: SourceCoreConfig, options?: AxiosRequestConfig) {
        return SchedulerApiFp(this.configuration).executeSourceDiscoverSchema(sourceCoreConfig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourceApi - axios parameter creator
 * @export
 */
export const SourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check connection to the source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToSource: async (sourceIdRequestBody: SourceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceIdRequestBody' is not null or undefined
            assertParamExists('checkConnectionToSource', 'sourceIdRequestBody', sourceIdRequestBody)
            const localVarPath = `/v1/sources/check_connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check connection for a proposed update to a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToSourceForUpdate: async (sourceUpdate: SourceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUpdate' is not null or undefined
            assertParamExists('checkConnectionToSourceForUpdate', 'sourceUpdate', sourceUpdate)
            const localVarPath = `/v1/sources/check_connection_for_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneSource: async (sourceIdRequestBody: SourceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceIdRequestBody' is not null or undefined
            assertParamExists('cloneSource', 'sourceIdRequestBody', sourceIdRequestBody)
            const localVarPath = `/v1/sources/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a source
         * @param {SourceCreate} sourceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourceCreate: SourceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceCreate' is not null or undefined
            assertParamExists('createSource', 'sourceCreate', sourceCreate)
            const localVarPath = `/v1/sources/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (sourceIdRequestBody: SourceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceIdRequestBody' is not null or undefined
            assertParamExists('deleteSource', 'sourceIdRequestBody', sourceIdRequestBody)
            const localVarPath = `/v1/sources/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover the schema catalog of the source
         * @param {SourceDiscoverSchemaRequestBody} sourceDiscoverSchemaRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverSchemaForSource: async (sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDiscoverSchemaRequestBody' is not null or undefined
            assertParamExists('discoverSchemaForSource', 'sourceDiscoverSchemaRequestBody', sourceDiscoverSchemaRequestBody)
            const localVarPath = `/v1/sources/discover_schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDiscoverSchemaRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (sourceIdRequestBody: SourceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceIdRequestBody' is not null or undefined
            assertParamExists('getSource', 'sourceIdRequestBody', sourceIdRequestBody)
            const localVarPath = `/v1/sources/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List sources for workspace. Does not return deleted sources.
         * @summary List sources for workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourcesForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('listSourcesForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/sources/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search sources
         * @param {SourceSearch} sourceSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources: async (sourceSearch: SourceSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceSearch' is not null or undefined
            assertParamExists('searchSources', 'sourceSearch', sourceSearch)
            const localVarPath = `/v1/sources/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (sourceUpdate: SourceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUpdate' is not null or undefined
            assertParamExists('updateSource', 'sourceUpdate', sourceUpdate)
            const localVarPath = `/v1/sources/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceApi - functional programming interface
 * @export
 */
export const SourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check connection to the source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionToSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionToSource(sourceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check connection for a proposed update to a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionToSourceForUpdate(sourceUpdate: SourceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionToSourceForUpdate(sourceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clone source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneSource(sourceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a source
         * @param {SourceCreate} sourceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourceCreate: SourceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(sourceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Discover the schema catalog of the source
         * @param {SourceDiscoverSchemaRequestBody} sourceDiscoverSchemaRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverSchemaForSource(sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDiscoverSchemaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverSchemaForSource(sourceDiscoverSchemaRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(sourceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List sources for workspace. Does not return deleted sources.
         * @summary List sources for workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourcesForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourcesForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search sources
         * @param {SourceSearch} sourceSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSources(sourceSearch: SourceSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSources(sourceSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(sourceUpdate: SourceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(sourceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourceApi - factory interface
 * @export
 */
export const SourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Check connection to the source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToSource(sourceIdRequestBody: SourceIdRequestBody, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.checkConnectionToSource(sourceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check connection for a proposed update to a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionToSourceForUpdate(sourceUpdate: SourceUpdate, options?: any): AxiosPromise<CheckConnectionRead> {
            return localVarFp.checkConnectionToSourceForUpdate(sourceUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clone source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneSource(sourceIdRequestBody: SourceIdRequestBody, options?: any): AxiosPromise<SourceRead> {
            return localVarFp.cloneSource(sourceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a source
         * @param {SourceCreate} sourceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sourceCreate: SourceCreate, options?: any): AxiosPromise<SourceRead> {
            return localVarFp.createSource(sourceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(sourceIdRequestBody: SourceIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource(sourceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover the schema catalog of the source
         * @param {SourceDiscoverSchemaRequestBody} sourceDiscoverSchemaRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverSchemaForSource(sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody, options?: any): AxiosPromise<SourceDiscoverSchemaRead> {
            return localVarFp.discoverSchemaForSource(sourceDiscoverSchemaRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get source
         * @param {SourceIdRequestBody} sourceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(sourceIdRequestBody: SourceIdRequestBody, options?: any): AxiosPromise<SourceRead> {
            return localVarFp.getSource(sourceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * List sources for workspace. Does not return deleted sources.
         * @summary List sources for workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourcesForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<SourceReadList> {
            return localVarFp.listSourcesForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search sources
         * @param {SourceSearch} sourceSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources(sourceSearch: SourceSearch, options?: any): AxiosPromise<SourceReadList> {
            return localVarFp.searchSources(sourceSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a source
         * @param {SourceUpdate} sourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(sourceUpdate: SourceUpdate, options?: any): AxiosPromise<SourceRead> {
            return localVarFp.updateSource(sourceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceApi - object-oriented interface
 * @export
 * @class SourceApi
 * @extends {BaseAPI}
 */
export class SourceApi extends BaseAPI {
    /**
     * 
     * @summary Check connection to the source
     * @param {SourceIdRequestBody} sourceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public checkConnectionToSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).checkConnectionToSource(sourceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check connection for a proposed update to a source
     * @param {SourceUpdate} sourceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public checkConnectionToSourceForUpdate(sourceUpdate: SourceUpdate, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).checkConnectionToSourceForUpdate(sourceUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clone source
     * @param {SourceIdRequestBody} sourceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public cloneSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).cloneSource(sourceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a source
     * @param {SourceCreate} sourceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public createSource(sourceCreate: SourceCreate, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).createSource(sourceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a source
     * @param {SourceIdRequestBody} sourceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public deleteSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).deleteSource(sourceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover the schema catalog of the source
     * @param {SourceDiscoverSchemaRequestBody} sourceDiscoverSchemaRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public discoverSchemaForSource(sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).discoverSchemaForSource(sourceDiscoverSchemaRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get source
     * @param {SourceIdRequestBody} sourceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public getSource(sourceIdRequestBody: SourceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).getSource(sourceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List sources for workspace. Does not return deleted sources.
     * @summary List sources for workspace
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public listSourcesForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).listSourcesForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search sources
     * @param {SourceSearch} sourceSearch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public searchSources(sourceSearch: SourceSearch, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).searchSources(sourceSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a source
     * @param {SourceUpdate} sourceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public updateSource(sourceUpdate: SourceUpdate, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).updateSource(sourceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourceDefinitionApi - axios parameter creator
 * @export
 */
export const SourceDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionCreate} [customSourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomSourceDefinition: async (customSourceDefinitionCreate?: CustomSourceDefinitionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/create_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customSourceDefinitionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a sourceDefinition
         * @param {SourceDefinitionCreate} [sourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSourceDefinition: async (sourceDefinitionCreate?: SourceDefinitionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom source definition for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomSourceDefinition: async (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('deleteCustomSourceDefinition', 'sourceDefinitionIdWithWorkspaceId', sourceDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/source_definitions/delete_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source definition
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceDefinition: async (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdRequestBody' is not null or undefined
            assertParamExists('deleteSourceDefinition', 'sourceDefinitionIdRequestBody', sourceDefinitionIdRequestBody)
            const localVarPath = `/v1/source_definitions/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get source
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinition: async (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdRequestBody' is not null or undefined
            assertParamExists('getSourceDefinition', 'sourceDefinitionIdRequestBody', sourceDefinitionIdRequestBody)
            const localVarPath = `/v1/source_definitions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sourceDefinition that is configured for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinitionForWorkspace: async (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('getSourceDefinitionForWorkspace', 'sourceDefinitionIdWithWorkspaceId', sourceDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/source_definitions/get_for_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary grant a private, non-custom sourceDefinition to a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantSourceDefinitionToWorkspace: async (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('grantSourceDefinitionToWorkspace', 'sourceDefinitionIdWithWorkspaceId', sourceDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/source_definitions/grant_definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Guaranteed to retrieve the latest information on supported sources.
         * @summary List the latest sourceDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLatestSourceDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/list_latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateSourceDefinitions: async (workspaceIdRequestBody?: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/list_private`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the sourceDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDefinitionsForWorkspace: async (workspaceIdRequestBody?: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/list_for_workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSourceDefinitionFromWorkspace: async (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('revokeSourceDefinitionFromWorkspace', 'sourceDefinitionIdWithWorkspaceId', sourceDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/source_definitions/revoke_definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionUpdate} [customSourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomSourceDefinition: async (customSourceDefinitionUpdate?: CustomSourceDefinitionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/update_custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customSourceDefinitionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a sourceDefinition
         * @param {SourceDefinitionUpdate} [sourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceDefinition: async (sourceDefinitionUpdate?: SourceDefinitionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/source_definitions/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceDefinitionApi - functional programming interface
 * @export
 */
export const SourceDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionCreate} [customSourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomSourceDefinition(customSourceDefinitionCreate?: CustomSourceDefinitionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomSourceDefinition(customSourceDefinitionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a sourceDefinition
         * @param {SourceDefinitionCreate} [sourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSourceDefinition(sourceDefinitionCreate?: SourceDefinitionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSourceDefinition(sourceDefinitionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a custom source definition for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a source definition
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSourceDefinition(sourceDefinitionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get source
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceDefinition(sourceDefinitionIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a sourceDefinition that is configured for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary grant a private, non-custom sourceDefinition to a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateSourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Guaranteed to retrieve the latest information on supported sources.
         * @summary List the latest sourceDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLatestSourceDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLatestSourceDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrivateSourceDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateSourceDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrivateSourceDefinitions(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourceDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the sourceDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSourceDefinitionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionUpdate} [customSourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomSourceDefinition(customSourceDefinitionUpdate?: CustomSourceDefinitionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomSourceDefinition(customSourceDefinitionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a sourceDefinition
         * @param {SourceDefinitionUpdate} [sourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSourceDefinition(sourceDefinitionUpdate?: SourceDefinitionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSourceDefinition(sourceDefinitionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourceDefinitionApi - factory interface
 * @export
 */
export const SourceDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionCreate} [customSourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomSourceDefinition(customSourceDefinitionCreate?: CustomSourceDefinitionCreate, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.createCustomSourceDefinition(customSourceDefinitionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a sourceDefinition
         * @param {SourceDefinitionCreate} [sourceDefinitionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSourceDefinition(sourceDefinitionCreate?: SourceDefinitionCreate, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.createSourceDefinition(sourceDefinitionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom source definition for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a source definition
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSourceDefinition(sourceDefinitionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get source
         * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.getSourceDefinition(sourceDefinitionIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a sourceDefinition that is configured for the given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary grant a private, non-custom sourceDefinition to a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<PrivateSourceDefinitionRead> {
            return localVarFp.grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Guaranteed to retrieve the latest information on supported sources.
         * @summary List the latest sourceDefinitions Airbyte supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLatestSourceDefinitions(options?: any): AxiosPromise<SourceDefinitionReadList> {
            return localVarFp.listLatestSourceDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrivateSourceDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: any): AxiosPromise<PrivateSourceDefinitionReadList> {
            return localVarFp.listPrivateSourceDefinitions(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDefinitions(options?: any): AxiosPromise<SourceDefinitionReadList> {
            return localVarFp.listSourceDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the sourceDefinitions the given workspace is configured to use
         * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: any): AxiosPromise<SourceDefinitionReadList> {
            return localVarFp.listSourceDefinitionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<void> {
            return localVarFp.revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a custom sourceDefinition for the given workspace
         * @param {CustomSourceDefinitionUpdate} [customSourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomSourceDefinition(customSourceDefinitionUpdate?: CustomSourceDefinitionUpdate, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.updateCustomSourceDefinition(customSourceDefinitionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a sourceDefinition
         * @param {SourceDefinitionUpdate} [sourceDefinitionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceDefinition(sourceDefinitionUpdate?: SourceDefinitionUpdate, options?: any): AxiosPromise<SourceDefinitionRead> {
            return localVarFp.updateSourceDefinition(sourceDefinitionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceDefinitionApi - object-oriented interface
 * @export
 * @class SourceDefinitionApi
 * @extends {BaseAPI}
 */
export class SourceDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Creates a custom sourceDefinition for the given workspace
     * @param {CustomSourceDefinitionCreate} [customSourceDefinitionCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public createCustomSourceDefinition(customSourceDefinitionCreate?: CustomSourceDefinitionCreate, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).createCustomSourceDefinition(customSourceDefinitionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a sourceDefinition
     * @param {SourceDefinitionCreate} [sourceDefinitionCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public createSourceDefinition(sourceDefinitionCreate?: SourceDefinitionCreate, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).createSourceDefinition(sourceDefinitionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom source definition for the given workspace
     * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).deleteCustomSourceDefinition(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a source definition
     * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public deleteSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).deleteSourceDefinition(sourceDefinitionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get source
     * @param {SourceDefinitionIdRequestBody} sourceDefinitionIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public getSourceDefinition(sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).getSourceDefinition(sourceDefinitionIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a sourceDefinition that is configured for the given workspace
     * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).getSourceDefinitionForWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary grant a private, non-custom sourceDefinition to a given workspace
     * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).grantSourceDefinitionToWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Guaranteed to retrieve the latest information on supported sources.
     * @summary List the latest sourceDefinitions Airbyte supports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public listLatestSourceDefinitions(options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).listLatestSourceDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace\'s grants.
     * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public listPrivateSourceDefinitions(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).listPrivateSourceDefinitions(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public listSourceDefinitions(options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).listSourceDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the sourceDefinitions the given workspace is configured to use
     * @param {WorkspaceIdRequestBody} [workspaceIdRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public listSourceDefinitionsForWorkspace(workspaceIdRequestBody?: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).listSourceDefinitionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
     * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).revokeSourceDefinitionFromWorkspace(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a custom sourceDefinition for the given workspace
     * @param {CustomSourceDefinitionUpdate} [customSourceDefinitionUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public updateCustomSourceDefinition(customSourceDefinitionUpdate?: CustomSourceDefinitionUpdate, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).updateCustomSourceDefinition(customSourceDefinitionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a sourceDefinition
     * @param {SourceDefinitionUpdate} [sourceDefinitionUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionApi
     */
    public updateSourceDefinition(sourceDefinitionUpdate?: SourceDefinitionUpdate, options?: AxiosRequestConfig) {
        return SourceDefinitionApiFp(this.configuration).updateSourceDefinition(sourceDefinitionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourceDefinitionSpecificationApi - axios parameter creator
 * @export
 */
export const SourceDefinitionSpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get specification for a SourceDefinition.
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinitionSpecification: async (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceDefinitionIdWithWorkspaceId' is not null or undefined
            assertParamExists('getSourceDefinitionSpecification', 'sourceDefinitionIdWithWorkspaceId', sourceDefinitionIdWithWorkspaceId)
            const localVarPath = `/v1/source_definition_specifications/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceDefinitionIdWithWorkspaceId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceDefinitionSpecificationApi - functional programming interface
 * @export
 */
export const SourceDefinitionSpecificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceDefinitionSpecificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get specification for a SourceDefinition.
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDefinitionSpecificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourceDefinitionSpecificationApi - factory interface
 * @export
 */
export const SourceDefinitionSpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceDefinitionSpecificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get specification for a SourceDefinition.
         * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: any): AxiosPromise<SourceDefinitionSpecificationRead> {
            return localVarFp.getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceDefinitionSpecificationApi - object-oriented interface
 * @export
 * @class SourceDefinitionSpecificationApi
 * @extends {BaseAPI}
 */
export class SourceDefinitionSpecificationApi extends BaseAPI {
    /**
     * 
     * @summary Get specification for a SourceDefinition.
     * @param {SourceDefinitionIdWithWorkspaceId} sourceDefinitionIdWithWorkspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceDefinitionSpecificationApi
     */
    public getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId, options?: AxiosRequestConfig) {
        return SourceDefinitionSpecificationApiFp(this.configuration).getSourceDefinitionSpecification(sourceDefinitionIdWithWorkspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebBackendApi - axios parameter creator
 * @export
 */
export const WebBackendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a connection
         * @param {WebBackendConnectionCreate} webBackendConnectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendCreateConnection: async (webBackendConnectionCreate: WebBackendConnectionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webBackendConnectionCreate' is not null or undefined
            assertParamExists('webBackendCreateConnection', 'webBackendConnectionCreate', webBackendConnectionCreate)
            const localVarPath = `/v1/web_backend/connections/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webBackendConnectionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connection
         * @param {WebBackendConnectionRequestBody} webBackendConnectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendGetConnection: async (webBackendConnectionRequestBody: WebBackendConnectionRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webBackendConnectionRequestBody' is not null or undefined
            assertParamExists('webBackendGetConnection', 'webBackendConnectionRequestBody', webBackendConnectionRequestBody)
            const localVarPath = `/v1/web_backend/connections/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webBackendConnectionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the current state of a workspace
         * @param {WebBackendWorkspaceState} [webBackendWorkspaceState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendGetWorkspaceState: async (webBackendWorkspaceState?: WebBackendWorkspaceState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/web_backend/workspace/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webBackendWorkspaceState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendListAllConnectionsForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('webBackendListAllConnectionsForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/web_backend/connections/list_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all non-deleted connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendListConnectionsForWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('webBackendListConnectionsForWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/web_backend/connections/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search connections
         * @param {WebBackendConnectionSearch} webBackendConnectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendSearchConnections: async (webBackendConnectionSearch: WebBackendConnectionSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webBackendConnectionSearch' is not null or undefined
            assertParamExists('webBackendSearchConnections', 'webBackendConnectionSearch', webBackendConnectionSearch)
            const localVarPath = `/v1/web_backend/connections/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webBackendConnectionSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a connection
         * @param {WebBackendConnectionUpdate} webBackendConnectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendUpdateConnection: async (webBackendConnectionUpdate: WebBackendConnectionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webBackendConnectionUpdate' is not null or undefined
            assertParamExists('webBackendUpdateConnection', 'webBackendConnectionUpdate', webBackendConnectionUpdate)
            const localVarPath = `/v1/web_backend/connections/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webBackendConnectionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebBackendApi - functional programming interface
 * @export
 */
export const WebBackendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebBackendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a connection
         * @param {WebBackendConnectionCreate} webBackendConnectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendCreateConnection(webBackendConnectionCreate: WebBackendConnectionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendCreateConnection(webBackendConnectionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connection
         * @param {WebBackendConnectionRequestBody} webBackendConnectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendGetConnection(webBackendConnectionRequestBody: WebBackendConnectionRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendGetConnection(webBackendConnectionRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the current state of a workspace
         * @param {WebBackendWorkspaceState} [webBackendWorkspaceState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendGetWorkspaceState(webBackendWorkspaceState?: WebBackendWorkspaceState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendWorkspaceStateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendGetWorkspaceState(webBackendWorkspaceState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all non-deleted connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendListConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendListConnectionsForWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search connections
         * @param {WebBackendConnectionSearch} webBackendConnectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendSearchConnections(webBackendConnectionSearch: WebBackendConnectionSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendSearchConnections(webBackendConnectionSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a connection
         * @param {WebBackendConnectionUpdate} webBackendConnectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webBackendUpdateConnection(webBackendConnectionUpdate: WebBackendConnectionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebBackendConnectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webBackendUpdateConnection(webBackendConnectionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebBackendApi - factory interface
 * @export
 */
export const WebBackendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebBackendApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a connection
         * @param {WebBackendConnectionCreate} webBackendConnectionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendCreateConnection(webBackendConnectionCreate: WebBackendConnectionCreate, options?: any): AxiosPromise<WebBackendConnectionRead> {
            return localVarFp.webBackendCreateConnection(webBackendConnectionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connection
         * @param {WebBackendConnectionRequestBody} webBackendConnectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendGetConnection(webBackendConnectionRequestBody: WebBackendConnectionRequestBody, options?: any): AxiosPromise<WebBackendConnectionRead> {
            return localVarFp.webBackendGetConnection(webBackendConnectionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the current state of a workspace
         * @param {WebBackendWorkspaceState} [webBackendWorkspaceState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendGetWorkspaceState(webBackendWorkspaceState?: WebBackendWorkspaceState, options?: any): AxiosPromise<WebBackendWorkspaceStateResult> {
            return localVarFp.webBackendGetWorkspaceState(webBackendWorkspaceState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<WebBackendConnectionReadList> {
            return localVarFp.webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all non-deleted connections for a workspace.
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendListConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<WebBackendConnectionReadList> {
            return localVarFp.webBackendListConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search connections
         * @param {WebBackendConnectionSearch} webBackendConnectionSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendSearchConnections(webBackendConnectionSearch: WebBackendConnectionSearch, options?: any): AxiosPromise<WebBackendConnectionReadList> {
            return localVarFp.webBackendSearchConnections(webBackendConnectionSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a connection
         * @param {WebBackendConnectionUpdate} webBackendConnectionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webBackendUpdateConnection(webBackendConnectionUpdate: WebBackendConnectionUpdate, options?: any): AxiosPromise<WebBackendConnectionRead> {
            return localVarFp.webBackendUpdateConnection(webBackendConnectionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebBackendApi - object-oriented interface
 * @export
 * @class WebBackendApi
 * @extends {BaseAPI}
 */
export class WebBackendApi extends BaseAPI {
    /**
     * 
     * @summary Create a connection
     * @param {WebBackendConnectionCreate} webBackendConnectionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendCreateConnection(webBackendConnectionCreate: WebBackendConnectionCreate, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendCreateConnection(webBackendConnectionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connection
     * @param {WebBackendConnectionRequestBody} webBackendConnectionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendGetConnection(webBackendConnectionRequestBody: WebBackendConnectionRequestBody, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendGetConnection(webBackendConnectionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the current state of a workspace
     * @param {WebBackendWorkspaceState} [webBackendWorkspaceState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendGetWorkspaceState(webBackendWorkspaceState?: WebBackendWorkspaceState, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendGetWorkspaceState(webBackendWorkspaceState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all connections for a workspace.
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendListAllConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all non-deleted connections for a workspace.
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendListConnectionsForWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendListConnectionsForWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search connections
     * @param {WebBackendConnectionSearch} webBackendConnectionSearch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendSearchConnections(webBackendConnectionSearch: WebBackendConnectionSearch, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendSearchConnections(webBackendConnectionSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a connection
     * @param {WebBackendConnectionUpdate} webBackendConnectionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebBackendApi
     */
    public webBackendUpdateConnection(webBackendConnectionUpdate: WebBackendConnectionUpdate, options?: AxiosRequestConfig) {
        return WebBackendApiFp(this.configuration).webBackendUpdateConnection(webBackendConnectionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a workspace
         * @param {WorkspaceCreate} workspaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (workspaceCreate: WorkspaceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreate' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreate', workspaceCreate)
            const localVarPath = `/v1/workspaces/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/workspaces/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find workspace by ID
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (workspaceIdRequestBody: WorkspaceIdRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceIdRequestBody' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceIdRequestBody', workspaceIdRequestBody)
            const localVarPath = `/v1/workspaces/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find workspace by slug
         * @param {SlugRequestBody} slugRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceBySlug: async (slugRequestBody: SlugRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slugRequestBody' is not null or undefined
            assertParamExists('getWorkspaceBySlug', 'slugRequestBody', slugRequestBody)
            const localVarPath = `/v1/workspaces/get_by_slug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slugRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all workspaces registered in the current Airbyte deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workspaces/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update workspace state
         * @param {WorkspaceUpdate} workspaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (workspaceUpdate: WorkspaceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceUpdate' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdate', workspaceUpdate)
            const localVarPath = `/v1/workspaces/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update workspace feedback state
         * @param {WorkspaceGiveFeedback} workspaceGiveFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceFeedback: async (workspaceGiveFeedback: WorkspaceGiveFeedback, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceGiveFeedback' is not null or undefined
            assertParamExists('updateWorkspaceFeedback', 'workspaceGiveFeedback', workspaceGiveFeedback)
            const localVarPath = `/v1/workspaces/tag_feedback_status_as_done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceGiveFeedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update workspace name
         * @param {WorkspaceUpdateName} workspaceUpdateName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceName: async (workspaceUpdateName: WorkspaceUpdateName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceUpdateName' is not null or undefined
            assertParamExists('updateWorkspaceName', 'workspaceUpdateName', workspaceUpdateName)
            const localVarPath = `/v1/workspaces/update_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a workspace
         * @param {WorkspaceCreate} workspaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(workspaceCreate: WorkspaceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(workspaceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find workspace by ID
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(workspaceIdRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find workspace by slug
         * @param {SlugRequestBody} slugRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceBySlug(slugRequestBody: SlugRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceBySlug(slugRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all workspaces registered in the current Airbyte deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaces(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update workspace state
         * @param {WorkspaceUpdate} workspaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(workspaceUpdate: WorkspaceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(workspaceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update workspace feedback state
         * @param {WorkspaceGiveFeedback} workspaceGiveFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceFeedback(workspaceGiveFeedback: WorkspaceGiveFeedback, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceFeedback(workspaceGiveFeedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update workspace name
         * @param {WorkspaceUpdateName} workspaceUpdateName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceName(workspaceUpdateName: WorkspaceUpdateName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceName(workspaceUpdateName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a workspace
         * @param {WorkspaceCreate} workspaceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(workspaceCreate: WorkspaceCreate, options?: any): AxiosPromise<WorkspaceRead> {
            return localVarFp.createWorkspace(workspaceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a workspace
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find workspace by ID
         * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: any): AxiosPromise<WorkspaceRead> {
            return localVarFp.getWorkspace(workspaceIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find workspace by slug
         * @param {SlugRequestBody} slugRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceBySlug(slugRequestBody: SlugRequestBody, options?: any): AxiosPromise<WorkspaceRead> {
            return localVarFp.getWorkspaceBySlug(slugRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all workspaces registered in the current Airbyte deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any): AxiosPromise<WorkspaceReadList> {
            return localVarFp.listWorkspaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update workspace state
         * @param {WorkspaceUpdate} workspaceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(workspaceUpdate: WorkspaceUpdate, options?: any): AxiosPromise<WorkspaceRead> {
            return localVarFp.updateWorkspace(workspaceUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update workspace feedback state
         * @param {WorkspaceGiveFeedback} workspaceGiveFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceFeedback(workspaceGiveFeedback: WorkspaceGiveFeedback, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspaceFeedback(workspaceGiveFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update workspace name
         * @param {WorkspaceUpdateName} workspaceUpdateName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceName(workspaceUpdateName: WorkspaceUpdateName, options?: any): AxiosPromise<WorkspaceRead> {
            return localVarFp.updateWorkspaceName(workspaceUpdateName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Creates a workspace
     * @param {WorkspaceCreate} workspaceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(workspaceCreate: WorkspaceCreate, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(workspaceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a workspace
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find workspace by ID
     * @param {WorkspaceIdRequestBody} workspaceIdRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspace(workspaceIdRequestBody: WorkspaceIdRequestBody, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspace(workspaceIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find workspace by slug
     * @param {SlugRequestBody} slugRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceBySlug(slugRequestBody: SlugRequestBody, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceBySlug(slugRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all workspaces registered in the current Airbyte deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaces(options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update workspace state
     * @param {WorkspaceUpdate} workspaceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(workspaceUpdate: WorkspaceUpdate, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(workspaceUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update workspace feedback state
     * @param {WorkspaceGiveFeedback} workspaceGiveFeedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceFeedback(workspaceGiveFeedback: WorkspaceGiveFeedback, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceFeedback(workspaceGiveFeedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update workspace name
     * @param {WorkspaceUpdateName} workspaceUpdateName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceName(workspaceUpdateName: WorkspaceUpdateName, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceName(workspaceUpdateName, options).then((request) => request(this.axios, this.basePath));
    }
}


